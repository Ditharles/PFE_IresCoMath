import {
  require_add_base_path,
  require_add_locale,
  require_add_locale2,
  require_add_path_prefix,
  require_constants,
  require_detect_domain_locale,
  require_escape_regexp,
  require_format_url,
  require_has_base_path,
  require_interception_routes,
  require_interpolate_as,
  require_is_dynamic,
  require_is_local_url,
  require_normalize_locale_path,
  require_omit,
  require_parse_path,
  require_path_has_prefix,
  require_querystring,
  require_remove_trailing_slash,
  require_request_idle_callback,
  require_resolve_href,
  require_route_matcher,
  require_route_regex,
  require_router_context_shared_runtime,
  require_utils,
  require_utils2
} from "./chunk-G4NWL63F.js";
import {
  require_interop_require_default,
  require_interop_require_wildcard
} from "./chunk-APKL7LEI.js";
import {
  require_jsx_runtime
} from "./chunk-JNNNAK6O.js";
import {
  require_react_dom
} from "./chunk-A7ECLLTJ.js";
import {
  require_react
} from "./chunk-HSUUC2QV.js";
import {
  __commonJS
} from "./chunk-DC5AMYBS.js";

// ../../../../node_modules/next/dist/shared/lib/router/utils/get-asset-path-from-route.js
var require_get_asset_path_from_route = __commonJS({
  "../../../../node_modules/next/dist/shared/lib/router/utils/get-asset-path-from-route.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return getAssetPathFromRoute;
      }
    });
    function getAssetPathFromRoute(route, ext) {
      if (ext === void 0) ext = "";
      const path = route === "/" ? "/index" : /^\/index(\/|$)/.test(route) ? "/index" + route : route;
      return path + ext;
    }
  }
});

// ../../../../node_modules/next/dist/client/trusted-types.js
var require_trusted_types = __commonJS({
  "../../../../node_modules/next/dist/client/trusted-types.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "__unsafeCreateTrustedScriptURL", {
      enumerable: true,
      get: function() {
        return __unsafeCreateTrustedScriptURL;
      }
    });
    var policy;
    function getPolicy() {
      if (typeof policy === "undefined" && typeof window !== "undefined") {
        var _window_trustedTypes;
        policy = ((_window_trustedTypes = window.trustedTypes) == null ? void 0 : _window_trustedTypes.createPolicy("nextjs", {
          createHTML: (input) => input,
          createScript: (input) => input,
          createScriptURL: (input) => input
        })) || null;
      }
      return policy;
    }
    function __unsafeCreateTrustedScriptURL(url) {
      var _getPolicy;
      return ((_getPolicy = getPolicy()) == null ? void 0 : _getPolicy.createScriptURL(url)) || url;
    }
    if ((typeof exports.default === "function" || typeof exports.default === "object" && exports.default !== null) && typeof exports.default.__esModule === "undefined") {
      Object.defineProperty(exports.default, "__esModule", { value: true });
      Object.assign(exports.default, exports);
      module.exports = exports.default;
    }
  }
});

// ../../../../node_modules/next/dist/build/deployment-id.js
var require_deployment_id = __commonJS({
  "../../../../node_modules/next/dist/build/deployment-id.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "getDeploymentIdQueryOrEmptyString", {
      enumerable: true,
      get: function() {
        return getDeploymentIdQueryOrEmptyString;
      }
    });
    function getDeploymentIdQueryOrEmptyString() {
      if (process.env.NEXT_DEPLOYMENT_ID) {
        return `?dpl=${process.env.NEXT_DEPLOYMENT_ID}`;
      }
      return "";
    }
  }
});

// ../../../../node_modules/next/dist/shared/lib/encode-uri-path.js
var require_encode_uri_path = __commonJS({
  "../../../../node_modules/next/dist/shared/lib/encode-uri-path.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "encodeURIPath", {
      enumerable: true,
      get: function() {
        return encodeURIPath;
      }
    });
    function encodeURIPath(file) {
      return file.split("/").map((p) => encodeURIComponent(p)).join("/");
    }
  }
});

// ../../../../node_modules/next/dist/client/route-loader.js
var require_route_loader = __commonJS({
  "../../../../node_modules/next/dist/client/route-loader.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all) Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
      });
    }
    _export(exports, {
      createRouteLoader: function() {
        return createRouteLoader;
      },
      getClientBuildManifest: function() {
        return getClientBuildManifest;
      },
      isAssetError: function() {
        return isAssetError;
      },
      markAssetError: function() {
        return markAssetError;
      }
    });
    var _interop_require_default = require_interop_require_default();
    var _getassetpathfromroute = _interop_require_default._(require_get_asset_path_from_route());
    var _trustedtypes = require_trusted_types();
    var _requestidlecallback = require_request_idle_callback();
    var _deploymentid = require_deployment_id();
    var _encodeuripath = require_encode_uri_path();
    var MS_MAX_IDLE_DELAY = 3800;
    function withFuture(key, map, generator) {
      let entry = map.get(key);
      if (entry) {
        if ("future" in entry) {
          return entry.future;
        }
        return Promise.resolve(entry);
      }
      let resolver;
      const prom = new Promise((resolve) => {
        resolver = resolve;
      });
      map.set(key, {
        resolve: resolver,
        future: prom
      });
      return generator ? generator().then((value) => {
        resolver(value);
        return value;
      }).catch((err) => {
        map.delete(key);
        throw err;
      }) : prom;
    }
    var ASSET_LOAD_ERROR = Symbol("ASSET_LOAD_ERROR");
    function markAssetError(err) {
      return Object.defineProperty(err, ASSET_LOAD_ERROR, {});
    }
    function isAssetError(err) {
      return err && ASSET_LOAD_ERROR in err;
    }
    function hasPrefetch(link) {
      try {
        link = document.createElement("link");
        return (
          // detect IE11 since it supports prefetch but isn't detected
          // with relList.support
          !!window.MSInputMethodContext && !!document.documentMode || link.relList.supports("prefetch")
        );
      } catch (e) {
        return false;
      }
    }
    var canPrefetch = hasPrefetch();
    var getAssetQueryString = () => {
      return (0, _deploymentid.getDeploymentIdQueryOrEmptyString)();
    };
    function prefetchViaDom(href, as, link) {
      return new Promise((resolve, reject) => {
        const selector = '\n      link[rel="prefetch"][href^="' + href + '"],\n      link[rel="preload"][href^="' + href + '"],\n      script[src^="' + href + '"]';
        if (document.querySelector(selector)) {
          return resolve();
        }
        link = document.createElement("link");
        if (as) link.as = as;
        link.rel = "prefetch";
        link.crossOrigin = process.env.__NEXT_CROSS_ORIGIN;
        link.onload = resolve;
        link.onerror = () => reject(markAssetError(new Error("Failed to prefetch: " + href)));
        link.href = href;
        document.head.appendChild(link);
      });
    }
    function appendScript(src, script) {
      return new Promise((resolve, reject) => {
        script = document.createElement("script");
        script.onload = resolve;
        script.onerror = () => reject(markAssetError(new Error("Failed to load script: " + src)));
        script.crossOrigin = process.env.__NEXT_CROSS_ORIGIN;
        script.src = src;
        document.body.appendChild(script);
      });
    }
    var devBuildPromise;
    function resolvePromiseWithTimeout(p, ms, err) {
      return new Promise((resolve, reject) => {
        let cancelled = false;
        p.then((r) => {
          cancelled = true;
          resolve(r);
        }).catch(reject);
        if (true) {
          ;
          (devBuildPromise || Promise.resolve()).then(() => {
            (0, _requestidlecallback.requestIdleCallback)(() => setTimeout(() => {
              if (!cancelled) {
                reject(err);
              }
            }, ms));
          });
        }
        if (false) {
          (0, _requestidlecallback.requestIdleCallback)(() => setTimeout(() => {
            if (!cancelled) {
              reject(err);
            }
          }, ms));
        }
      });
    }
    function getClientBuildManifest() {
      if (self.__BUILD_MANIFEST) {
        return Promise.resolve(self.__BUILD_MANIFEST);
      }
      const onBuildManifest = new Promise((resolve) => {
        const cb = self.__BUILD_MANIFEST_CB;
        self.__BUILD_MANIFEST_CB = () => {
          resolve(self.__BUILD_MANIFEST);
          cb && cb();
        };
      });
      return resolvePromiseWithTimeout(onBuildManifest, MS_MAX_IDLE_DELAY, markAssetError(new Error("Failed to load client build manifest")));
    }
    function getFilesForRoute(assetPrefix, route) {
      if (true) {
        const scriptUrl = assetPrefix + "/_next/static/chunks/pages" + (0, _encodeuripath.encodeURIPath)((0, _getassetpathfromroute.default)(route, ".js")) + getAssetQueryString();
        return Promise.resolve({
          scripts: [
            (0, _trustedtypes.__unsafeCreateTrustedScriptURL)(scriptUrl)
          ],
          // Styles are handled by `style-loader` in development:
          css: []
        });
      }
      return getClientBuildManifest().then((manifest) => {
        if (!(route in manifest)) {
          throw markAssetError(new Error("Failed to lookup route: " + route));
        }
        const allFiles = manifest[route].map((entry) => assetPrefix + "/_next/" + (0, _encodeuripath.encodeURIPath)(entry));
        return {
          scripts: allFiles.filter((v) => v.endsWith(".js")).map((v) => (0, _trustedtypes.__unsafeCreateTrustedScriptURL)(v) + getAssetQueryString()),
          css: allFiles.filter((v) => v.endsWith(".css")).map((v) => v + getAssetQueryString())
        };
      });
    }
    function createRouteLoader(assetPrefix) {
      const entrypoints = /* @__PURE__ */ new Map();
      const loadedScripts = /* @__PURE__ */ new Map();
      const styleSheets = /* @__PURE__ */ new Map();
      const routes = /* @__PURE__ */ new Map();
      function maybeExecuteScript(src) {
        if (false) {
          let prom = loadedScripts.get(src.toString());
          if (prom) {
            return prom;
          }
          if (document.querySelector('script[src^="' + src + '"]')) {
            return Promise.resolve();
          }
          loadedScripts.set(src.toString(), prom = appendScript(src));
          return prom;
        } else {
          return appendScript(src);
        }
      }
      function fetchStyleSheet(href) {
        let prom = styleSheets.get(href);
        if (prom) {
          return prom;
        }
        styleSheets.set(href, prom = fetch(href, {
          credentials: "same-origin"
        }).then((res) => {
          if (!res.ok) {
            throw new Error("Failed to load stylesheet: " + href);
          }
          return res.text().then((text) => ({
            href,
            content: text
          }));
        }).catch((err) => {
          throw markAssetError(err);
        }));
        return prom;
      }
      return {
        whenEntrypoint(route) {
          return withFuture(route, entrypoints);
        },
        onEntrypoint(route, execute) {
          ;
          (execute ? Promise.resolve().then(() => execute()).then((exports1) => ({
            component: exports1 && exports1.default || exports1,
            exports: exports1
          }), (err) => ({
            error: err
          })) : Promise.resolve(void 0)).then((input) => {
            const old = entrypoints.get(route);
            if (old && "resolve" in old) {
              if (input) {
                entrypoints.set(route, input);
                old.resolve(input);
              }
            } else {
              if (input) {
                entrypoints.set(route, input);
              } else {
                entrypoints.delete(route);
              }
              routes.delete(route);
            }
          });
        },
        loadRoute(route, prefetch) {
          return withFuture(route, routes, () => {
            let devBuildPromiseResolve;
            if (true) {
              devBuildPromise = new Promise((resolve) => {
                devBuildPromiseResolve = resolve;
              });
            }
            return resolvePromiseWithTimeout(getFilesForRoute(assetPrefix, route).then((param) => {
              let { scripts, css } = param;
              return Promise.all([
                entrypoints.has(route) ? [] : Promise.all(scripts.map(maybeExecuteScript)),
                Promise.all(css.map(fetchStyleSheet))
              ]);
            }).then((res) => {
              return this.whenEntrypoint(route).then((entrypoint) => ({
                entrypoint,
                styles: res[1]
              }));
            }), MS_MAX_IDLE_DELAY, markAssetError(new Error("Route did not complete loading: " + route))).then((param) => {
              let { entrypoint, styles } = param;
              const res = Object.assign({
                styles
              }, entrypoint);
              return "error" in entrypoint ? entrypoint : res;
            }).catch((err) => {
              if (prefetch) {
                throw err;
              }
              return {
                error: err
              };
            }).finally(() => devBuildPromiseResolve == null ? void 0 : devBuildPromiseResolve());
          });
        },
        prefetch(route) {
          let cn;
          if (cn = navigator.connection) {
            if (cn.saveData || /2g/.test(cn.effectiveType)) return Promise.resolve();
          }
          return getFilesForRoute(assetPrefix, route).then((output) => Promise.all(canPrefetch ? output.scripts.map((script) => prefetchViaDom(script.toString(), "script")) : [])).then(() => {
            (0, _requestidlecallback.requestIdleCallback)(() => this.loadRoute(route, true).catch(() => {
            }));
          }).catch(
            // swallow prefetch errors
            () => {
            }
          );
        }
      };
    }
    if ((typeof exports.default === "function" || typeof exports.default === "object" && exports.default !== null) && typeof exports.default.__esModule === "undefined") {
      Object.defineProperty(exports.default, "__esModule", { value: true });
      Object.assign(exports.default, exports);
      module.exports = exports.default;
    }
  }
});

// ../../../../node_modules/next/dist/shared/lib/head-manager-context.shared-runtime.js
var require_head_manager_context_shared_runtime = __commonJS({
  "../../../../node_modules/next/dist/shared/lib/head-manager-context.shared-runtime.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "HeadManagerContext", {
      enumerable: true,
      get: function() {
        return HeadManagerContext;
      }
    });
    var _interop_require_default = require_interop_require_default();
    var _react = _interop_require_default._(require_react());
    var HeadManagerContext = _react.default.createContext({});
    if (true) {
      HeadManagerContext.displayName = "HeadManagerContext";
    }
  }
});

// ../../../../node_modules/next/dist/client/set-attributes-from-props.js
var require_set_attributes_from_props = __commonJS({
  "../../../../node_modules/next/dist/client/set-attributes-from-props.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "setAttributesFromProps", {
      enumerable: true,
      get: function() {
        return setAttributesFromProps;
      }
    });
    var DOMAttributeNames = {
      acceptCharset: "accept-charset",
      className: "class",
      htmlFor: "for",
      httpEquiv: "http-equiv",
      noModule: "noModule"
    };
    var ignoreProps = [
      "onLoad",
      "onReady",
      "dangerouslySetInnerHTML",
      "children",
      "onError",
      "strategy",
      "stylesheets"
    ];
    function isBooleanScriptAttribute(attr) {
      return [
        "async",
        "defer",
        "noModule"
      ].includes(attr);
    }
    function setAttributesFromProps(el, props) {
      for (const [p, value] of Object.entries(props)) {
        if (!props.hasOwnProperty(p)) continue;
        if (ignoreProps.includes(p)) continue;
        if (value === void 0) {
          continue;
        }
        const attr = DOMAttributeNames[p] || p.toLowerCase();
        if (el.tagName === "SCRIPT" && isBooleanScriptAttribute(attr)) {
          ;
          el[attr] = !!value;
        } else {
          el.setAttribute(attr, String(value));
        }
        if (value === false || el.tagName === "SCRIPT" && isBooleanScriptAttribute(attr) && (!value || value === "false")) {
          el.setAttribute(attr, "");
          el.removeAttribute(attr);
        }
      }
    }
    if ((typeof exports.default === "function" || typeof exports.default === "object" && exports.default !== null) && typeof exports.default.__esModule === "undefined") {
      Object.defineProperty(exports.default, "__esModule", { value: true });
      Object.assign(exports.default, exports);
      module.exports = exports.default;
    }
  }
});

// ../../../../node_modules/next/dist/client/script.js
var require_script = __commonJS({
  "../../../../node_modules/next/dist/client/script.js"(exports, module) {
    "use client";
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all) Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
      });
    }
    _export(exports, {
      default: function() {
        return _default;
      },
      handleClientScriptLoad: function() {
        return handleClientScriptLoad;
      },
      initScriptLoader: function() {
        return initScriptLoader;
      }
    });
    var _interop_require_default = require_interop_require_default();
    var _interop_require_wildcard = require_interop_require_wildcard();
    var _jsxruntime = require_jsx_runtime();
    var _reactdom = _interop_require_default._(require_react_dom());
    var _react = _interop_require_wildcard._(require_react());
    var _headmanagercontextsharedruntime = require_head_manager_context_shared_runtime();
    var _setattributesfromprops = require_set_attributes_from_props();
    var _requestidlecallback = require_request_idle_callback();
    var ScriptCache = /* @__PURE__ */ new Map();
    var LoadCache = /* @__PURE__ */ new Set();
    var insertStylesheets = (stylesheets) => {
      if (_reactdom.default.preinit) {
        stylesheets.forEach((stylesheet) => {
          _reactdom.default.preinit(stylesheet, {
            as: "style"
          });
        });
        return;
      }
      if (typeof window !== "undefined") {
        let head = document.head;
        stylesheets.forEach((stylesheet) => {
          let link = document.createElement("link");
          link.type = "text/css";
          link.rel = "stylesheet";
          link.href = stylesheet;
          head.appendChild(link);
        });
      }
    };
    var loadScript = (props) => {
      const { src, id, onLoad = () => {
      }, onReady = null, dangerouslySetInnerHTML, children = "", strategy = "afterInteractive", onError, stylesheets } = props;
      const cacheKey = id || src;
      if (cacheKey && LoadCache.has(cacheKey)) {
        return;
      }
      if (ScriptCache.has(src)) {
        LoadCache.add(cacheKey);
        ScriptCache.get(src).then(onLoad, onError);
        return;
      }
      const afterLoad = () => {
        if (onReady) {
          onReady();
        }
        LoadCache.add(cacheKey);
      };
      const el = document.createElement("script");
      const loadPromise = new Promise((resolve, reject) => {
        el.addEventListener("load", function(e) {
          resolve();
          if (onLoad) {
            onLoad.call(this, e);
          }
          afterLoad();
        });
        el.addEventListener("error", function(e) {
          reject(e);
        });
      }).catch(function(e) {
        if (onError) {
          onError(e);
        }
      });
      if (dangerouslySetInnerHTML) {
        el.innerHTML = dangerouslySetInnerHTML.__html || "";
        afterLoad();
      } else if (children) {
        el.textContent = typeof children === "string" ? children : Array.isArray(children) ? children.join("") : "";
        afterLoad();
      } else if (src) {
        el.src = src;
        ScriptCache.set(src, loadPromise);
      }
      (0, _setattributesfromprops.setAttributesFromProps)(el, props);
      if (strategy === "worker") {
        el.setAttribute("type", "text/partytown");
      }
      el.setAttribute("data-nscript", strategy);
      if (stylesheets) {
        insertStylesheets(stylesheets);
      }
      document.body.appendChild(el);
    };
    function handleClientScriptLoad(props) {
      const { strategy = "afterInteractive" } = props;
      if (strategy === "lazyOnload") {
        window.addEventListener("load", () => {
          (0, _requestidlecallback.requestIdleCallback)(() => loadScript(props));
        });
      } else {
        loadScript(props);
      }
    }
    function loadLazyScript(props) {
      if (document.readyState === "complete") {
        (0, _requestidlecallback.requestIdleCallback)(() => loadScript(props));
      } else {
        window.addEventListener("load", () => {
          (0, _requestidlecallback.requestIdleCallback)(() => loadScript(props));
        });
      }
    }
    function addBeforeInteractiveToCache() {
      const scripts = [
        ...document.querySelectorAll('[data-nscript="beforeInteractive"]'),
        ...document.querySelectorAll('[data-nscript="beforePageRender"]')
      ];
      scripts.forEach((script) => {
        const cacheKey = script.id || script.getAttribute("src");
        LoadCache.add(cacheKey);
      });
    }
    function initScriptLoader(scriptLoaderItems) {
      scriptLoaderItems.forEach(handleClientScriptLoad);
      addBeforeInteractiveToCache();
    }
    function Script(props) {
      const { id, src = "", onLoad = () => {
      }, onReady = null, strategy = "afterInteractive", onError, stylesheets, ...restProps } = props;
      const { updateScripts, scripts, getIsSsr, appDir, nonce } = (0, _react.useContext)(_headmanagercontextsharedruntime.HeadManagerContext);
      const hasOnReadyEffectCalled = (0, _react.useRef)(false);
      (0, _react.useEffect)(() => {
        const cacheKey = id || src;
        if (!hasOnReadyEffectCalled.current) {
          if (onReady && cacheKey && LoadCache.has(cacheKey)) {
            onReady();
          }
          hasOnReadyEffectCalled.current = true;
        }
      }, [
        onReady,
        id,
        src
      ]);
      const hasLoadScriptEffectCalled = (0, _react.useRef)(false);
      (0, _react.useEffect)(() => {
        if (!hasLoadScriptEffectCalled.current) {
          if (strategy === "afterInteractive") {
            loadScript(props);
          } else if (strategy === "lazyOnload") {
            loadLazyScript(props);
          }
          hasLoadScriptEffectCalled.current = true;
        }
      }, [
        props,
        strategy
      ]);
      if (strategy === "beforeInteractive" || strategy === "worker") {
        if (updateScripts) {
          scripts[strategy] = (scripts[strategy] || []).concat([
            {
              id,
              src,
              onLoad,
              onReady,
              onError,
              ...restProps
            }
          ]);
          updateScripts(scripts);
        } else if (getIsSsr && getIsSsr()) {
          LoadCache.add(id || src);
        } else if (getIsSsr && !getIsSsr()) {
          loadScript(props);
        }
      }
      if (appDir) {
        if (stylesheets) {
          stylesheets.forEach((styleSrc) => {
            _reactdom.default.preinit(styleSrc, {
              as: "style"
            });
          });
        }
        if (strategy === "beforeInteractive") {
          if (!src) {
            if (restProps.dangerouslySetInnerHTML) {
              restProps.children = restProps.dangerouslySetInnerHTML.__html;
              delete restProps.dangerouslySetInnerHTML;
            }
            return (0, _jsxruntime.jsx)("script", {
              nonce,
              dangerouslySetInnerHTML: {
                __html: "(self.__next_s=self.__next_s||[]).push(" + JSON.stringify([
                  0,
                  {
                    ...restProps,
                    id
                  }
                ]) + ")"
              }
            });
          } else {
            _reactdom.default.preload(src, restProps.integrity ? {
              as: "script",
              integrity: restProps.integrity,
              nonce,
              crossOrigin: restProps.crossOrigin
            } : {
              as: "script",
              nonce,
              crossOrigin: restProps.crossOrigin
            });
            return (0, _jsxruntime.jsx)("script", {
              nonce,
              dangerouslySetInnerHTML: {
                __html: "(self.__next_s=self.__next_s||[]).push(" + JSON.stringify([
                  src,
                  {
                    ...restProps,
                    id
                  }
                ]) + ")"
              }
            });
          }
        } else if (strategy === "afterInteractive") {
          if (src) {
            _reactdom.default.preload(src, restProps.integrity ? {
              as: "script",
              integrity: restProps.integrity,
              nonce,
              crossOrigin: restProps.crossOrigin
            } : {
              as: "script",
              nonce,
              crossOrigin: restProps.crossOrigin
            });
          }
        }
      }
      return null;
    }
    Object.defineProperty(Script, "__nextScript", {
      value: true
    });
    var _default = Script;
    if ((typeof exports.default === "function" || typeof exports.default === "object" && exports.default !== null) && typeof exports.default.__esModule === "undefined") {
      Object.defineProperty(exports.default, "__esModule", { value: true });
      Object.assign(exports.default, exports);
      module.exports = exports.default;
    }
  }
});

// ../../../../node_modules/next/dist/shared/lib/is-plain-object.js
var require_is_plain_object = __commonJS({
  "../../../../node_modules/next/dist/shared/lib/is-plain-object.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all) Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
      });
    }
    _export(exports, {
      getObjectClassLabel: function() {
        return getObjectClassLabel;
      },
      isPlainObject: function() {
        return isPlainObject;
      }
    });
    function getObjectClassLabel(value) {
      return Object.prototype.toString.call(value);
    }
    function isPlainObject(value) {
      if (getObjectClassLabel(value) !== "[object Object]") {
        return false;
      }
      const prototype = Object.getPrototypeOf(value);
      return prototype === null || prototype.hasOwnProperty("isPrototypeOf");
    }
  }
});

// ../../../../node_modules/next/dist/lib/is-error.js
var require_is_error = __commonJS({
  "../../../../node_modules/next/dist/lib/is-error.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all) Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
      });
    }
    _export(exports, {
      /**
      * Checks whether the given value is a NextError.
      * This can be used to print a more detailed error message with properties like `code` & `digest`.
      */
      default: function() {
        return isError;
      },
      getProperError: function() {
        return getProperError;
      }
    });
    var _isplainobject = require_is_plain_object();
    function isError(err) {
      return typeof err === "object" && err !== null && "name" in err && "message" in err;
    }
    function safeStringify(obj) {
      const seen = /* @__PURE__ */ new WeakSet();
      return JSON.stringify(obj, (_key, value) => {
        if (typeof value === "object" && value !== null) {
          if (seen.has(value)) {
            return "[Circular]";
          }
          seen.add(value);
        }
        return value;
      });
    }
    function getProperError(err) {
      if (isError(err)) {
        return err;
      }
      if (true) {
        if (typeof err === "undefined") {
          return new Error("An undefined error was thrown, see here for more info: https://nextjs.org/docs/messages/threw-undefined");
        }
        if (err === null) {
          return new Error("A null error was thrown, see here for more info: https://nextjs.org/docs/messages/threw-undefined");
        }
      }
      return new Error((0, _isplainobject.isPlainObject)(err) ? safeStringify(err) : err + "");
    }
  }
});

// ../../../../node_modules/next/dist/shared/lib/page-path/normalize-path-sep.js
var require_normalize_path_sep = __commonJS({
  "../../../../node_modules/next/dist/shared/lib/page-path/normalize-path-sep.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "normalizePathSep", {
      enumerable: true,
      get: function() {
        return normalizePathSep;
      }
    });
    function normalizePathSep(path) {
      return path.replace(/\\/g, "/");
    }
  }
});

// ../../../../node_modules/next/dist/shared/lib/page-path/denormalize-page-path.js
var require_denormalize_page_path = __commonJS({
  "../../../../node_modules/next/dist/shared/lib/page-path/denormalize-page-path.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "denormalizePagePath", {
      enumerable: true,
      get: function() {
        return denormalizePagePath;
      }
    });
    var _utils = require_utils2();
    var _normalizepathsep = require_normalize_path_sep();
    function denormalizePagePath(page) {
      let _page = (0, _normalizepathsep.normalizePathSep)(page);
      return _page.startsWith("/index/") && !(0, _utils.isDynamicRoute)(_page) ? _page.slice(6) : _page !== "/index" ? _page : "/";
    }
  }
});

// ../../../../node_modules/next/dist/shared/lib/mitt.js
var require_mitt = __commonJS({
  "../../../../node_modules/next/dist/shared/lib/mitt.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return mitt;
      }
    });
    function mitt() {
      const all = /* @__PURE__ */ Object.create(null);
      return {
        on(type, handler) {
          ;
          (all[type] || (all[type] = [])).push(handler);
        },
        off(type, handler) {
          if (all[type]) {
            all[type].splice(all[type].indexOf(handler) >>> 0, 1);
          }
        },
        emit(type) {
          for (var _len = arguments.length, evts = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
            evts[_key - 1] = arguments[_key];
          }
          ;
          (all[type] || []).slice().map((handler) => {
            handler(...evts);
          });
        }
      };
    }
  }
});

// ../../../../node_modules/next/dist/shared/lib/router/utils/parse-relative-url.js
var require_parse_relative_url = __commonJS({
  "../../../../node_modules/next/dist/shared/lib/router/utils/parse-relative-url.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "parseRelativeUrl", {
      enumerable: true,
      get: function() {
        return parseRelativeUrl;
      }
    });
    var _utils = require_utils();
    var _querystring = require_querystring();
    function parseRelativeUrl(url, base, parseQuery) {
      if (parseQuery === void 0) parseQuery = true;
      const globalBase = new URL(typeof window === "undefined" ? "http://n" : (0, _utils.getLocationOrigin)());
      const resolvedBase = base ? new URL(base, globalBase) : url.startsWith(".") ? new URL(typeof window === "undefined" ? "http://n" : window.location.href) : globalBase;
      const { pathname, searchParams, search, hash, href, origin } = new URL(url, resolvedBase);
      if (origin !== globalBase.origin) {
        throw new Error("invariant: invalid relative URL, router received " + url);
      }
      return {
        pathname,
        query: parseQuery ? (0, _querystring.searchParamsToUrlQuery)(searchParams) : void 0,
        search,
        hash,
        href: href.slice(origin.length)
      };
    }
  }
});

// ../../../../node_modules/next/dist/compiled/path-to-regexp/index.js
var require_path_to_regexp = __commonJS({
  "../../../../node_modules/next/dist/compiled/path-to-regexp/index.js"(exports, module) {
    (() => {
      "use strict";
      if (typeof __nccwpck_require__ !== "undefined") __nccwpck_require__.ab = __dirname + "/";
      var e = {};
      (() => {
        var r = e;
        Object.defineProperty(r, "__esModule", { value: true });
        function lexer(e2) {
          var r2 = [];
          var n = 0;
          while (n < e2.length) {
            var t = e2[n];
            if (t === "*" || t === "+" || t === "?") {
              r2.push({ type: "MODIFIER", index: n, value: e2[n++] });
              continue;
            }
            if (t === "\\") {
              r2.push({ type: "ESCAPED_CHAR", index: n++, value: e2[n++] });
              continue;
            }
            if (t === "{") {
              r2.push({ type: "OPEN", index: n, value: e2[n++] });
              continue;
            }
            if (t === "}") {
              r2.push({ type: "CLOSE", index: n, value: e2[n++] });
              continue;
            }
            if (t === ":") {
              var i = "";
              var a = n + 1;
              while (a < e2.length) {
                var o = e2.charCodeAt(a);
                if (o >= 48 && o <= 57 || o >= 65 && o <= 90 || o >= 97 && o <= 122 || o === 95) {
                  i += e2[a++];
                  continue;
                }
                break;
              }
              if (!i) throw new TypeError("Missing parameter name at " + n);
              r2.push({ type: "NAME", index: n, value: i });
              n = a;
              continue;
            }
            if (t === "(") {
              var f = 1;
              var u = "";
              var a = n + 1;
              if (e2[a] === "?") {
                throw new TypeError('Pattern cannot start with "?" at ' + a);
              }
              while (a < e2.length) {
                if (e2[a] === "\\") {
                  u += e2[a++] + e2[a++];
                  continue;
                }
                if (e2[a] === ")") {
                  f--;
                  if (f === 0) {
                    a++;
                    break;
                  }
                } else if (e2[a] === "(") {
                  f++;
                  if (e2[a + 1] !== "?") {
                    throw new TypeError("Capturing groups are not allowed at " + a);
                  }
                }
                u += e2[a++];
              }
              if (f) throw new TypeError("Unbalanced pattern at " + n);
              if (!u) throw new TypeError("Missing pattern at " + n);
              r2.push({ type: "PATTERN", index: n, value: u });
              n = a;
              continue;
            }
            r2.push({ type: "CHAR", index: n, value: e2[n++] });
          }
          r2.push({ type: "END", index: n, value: "" });
          return r2;
        }
        function parse(e2, r2) {
          if (r2 === void 0) {
            r2 = {};
          }
          var n = lexer(e2);
          var t = r2.prefixes, i = t === void 0 ? "./" : t;
          var a = "[^" + escapeString(r2.delimiter || "/#?") + "]+?";
          var o = [];
          var f = 0;
          var u = 0;
          var p = "";
          var tryConsume = function(e3) {
            if (u < n.length && n[u].type === e3) return n[u++].value;
          };
          var mustConsume = function(e3) {
            var r3 = tryConsume(e3);
            if (r3 !== void 0) return r3;
            var t2 = n[u], i2 = t2.type, a2 = t2.index;
            throw new TypeError("Unexpected " + i2 + " at " + a2 + ", expected " + e3);
          };
          var consumeText = function() {
            var e3 = "";
            var r3;
            while (r3 = tryConsume("CHAR") || tryConsume("ESCAPED_CHAR")) {
              e3 += r3;
            }
            return e3;
          };
          while (u < n.length) {
            var v = tryConsume("CHAR");
            var c = tryConsume("NAME");
            var s = tryConsume("PATTERN");
            if (c || s) {
              var d = v || "";
              if (i.indexOf(d) === -1) {
                p += d;
                d = "";
              }
              if (p) {
                o.push(p);
                p = "";
              }
              o.push({ name: c || f++, prefix: d, suffix: "", pattern: s || a, modifier: tryConsume("MODIFIER") || "" });
              continue;
            }
            var g = v || tryConsume("ESCAPED_CHAR");
            if (g) {
              p += g;
              continue;
            }
            if (p) {
              o.push(p);
              p = "";
            }
            var x = tryConsume("OPEN");
            if (x) {
              var d = consumeText();
              var l = tryConsume("NAME") || "";
              var h = tryConsume("PATTERN") || "";
              var m = consumeText();
              mustConsume("CLOSE");
              o.push({ name: l || (h ? f++ : ""), pattern: l && !h ? a : h, prefix: d, suffix: m, modifier: tryConsume("MODIFIER") || "" });
              continue;
            }
            mustConsume("END");
          }
          return o;
        }
        r.parse = parse;
        function compile(e2, r2) {
          return tokensToFunction(parse(e2, r2), r2);
        }
        r.compile = compile;
        function tokensToFunction(e2, r2) {
          if (r2 === void 0) {
            r2 = {};
          }
          var n = flags(r2);
          var t = r2.encode, i = t === void 0 ? function(e3) {
            return e3;
          } : t, a = r2.validate, o = a === void 0 ? true : a;
          var f = e2.map(function(e3) {
            if (typeof e3 === "object") {
              return new RegExp("^(?:" + e3.pattern + ")$", n);
            }
          });
          return function(r3) {
            var n2 = "";
            for (var t2 = 0; t2 < e2.length; t2++) {
              var a2 = e2[t2];
              if (typeof a2 === "string") {
                n2 += a2;
                continue;
              }
              var u = r3 ? r3[a2.name] : void 0;
              var p = a2.modifier === "?" || a2.modifier === "*";
              var v = a2.modifier === "*" || a2.modifier === "+";
              if (Array.isArray(u)) {
                if (!v) {
                  throw new TypeError('Expected "' + a2.name + '" to not repeat, but got an array');
                }
                if (u.length === 0) {
                  if (p) continue;
                  throw new TypeError('Expected "' + a2.name + '" to not be empty');
                }
                for (var c = 0; c < u.length; c++) {
                  var s = i(u[c], a2);
                  if (o && !f[t2].test(s)) {
                    throw new TypeError('Expected all "' + a2.name + '" to match "' + a2.pattern + '", but got "' + s + '"');
                  }
                  n2 += a2.prefix + s + a2.suffix;
                }
                continue;
              }
              if (typeof u === "string" || typeof u === "number") {
                var s = i(String(u), a2);
                if (o && !f[t2].test(s)) {
                  throw new TypeError('Expected "' + a2.name + '" to match "' + a2.pattern + '", but got "' + s + '"');
                }
                n2 += a2.prefix + s + a2.suffix;
                continue;
              }
              if (p) continue;
              var d = v ? "an array" : "a string";
              throw new TypeError('Expected "' + a2.name + '" to be ' + d);
            }
            return n2;
          };
        }
        r.tokensToFunction = tokensToFunction;
        function match(e2, r2) {
          var n = [];
          var t = pathToRegexp(e2, n, r2);
          return regexpToFunction(t, n, r2);
        }
        r.match = match;
        function regexpToFunction(e2, r2, n) {
          if (n === void 0) {
            n = {};
          }
          var t = n.decode, i = t === void 0 ? function(e3) {
            return e3;
          } : t;
          return function(n2) {
            var t2 = e2.exec(n2);
            if (!t2) return false;
            var a = t2[0], o = t2.index;
            var f = /* @__PURE__ */ Object.create(null);
            var _loop_1 = function(e3) {
              if (t2[e3] === void 0) return "continue";
              var n3 = r2[e3 - 1];
              if (n3.modifier === "*" || n3.modifier === "+") {
                f[n3.name] = t2[e3].split(n3.prefix + n3.suffix).map(function(e4) {
                  return i(e4, n3);
                });
              } else {
                f[n3.name] = i(t2[e3], n3);
              }
            };
            for (var u = 1; u < t2.length; u++) {
              _loop_1(u);
            }
            return { path: a, index: o, params: f };
          };
        }
        r.regexpToFunction = regexpToFunction;
        function escapeString(e2) {
          return e2.replace(/([.+*?=^!:${}()[\]|/\\])/g, "\\$1");
        }
        function flags(e2) {
          return e2 && e2.sensitive ? "" : "i";
        }
        function regexpToRegexp(e2, r2) {
          if (!r2) return e2;
          var n = e2.source.match(/\((?!\?)/g);
          if (n) {
            for (var t = 0; t < n.length; t++) {
              r2.push({ name: t, prefix: "", suffix: "", modifier: "", pattern: "" });
            }
          }
          return e2;
        }
        function arrayToRegexp(e2, r2, n) {
          var t = e2.map(function(e3) {
            return pathToRegexp(e3, r2, n).source;
          });
          return new RegExp("(?:" + t.join("|") + ")", flags(n));
        }
        function stringToRegexp(e2, r2, n) {
          return tokensToRegexp(parse(e2, n), r2, n);
        }
        function tokensToRegexp(e2, r2, n) {
          if (n === void 0) {
            n = {};
          }
          var t = n.strict, i = t === void 0 ? false : t, a = n.start, o = a === void 0 ? true : a, f = n.end, u = f === void 0 ? true : f, p = n.encode, v = p === void 0 ? function(e3) {
            return e3;
          } : p;
          var c = "[" + escapeString(n.endsWith || "") + "]|$";
          var s = "[" + escapeString(n.delimiter || "/#?") + "]";
          var d = o ? "^" : "";
          for (var g = 0, x = e2; g < x.length; g++) {
            var l = x[g];
            if (typeof l === "string") {
              d += escapeString(v(l));
            } else {
              var h = escapeString(v(l.prefix));
              var m = escapeString(v(l.suffix));
              if (l.pattern) {
                if (r2) r2.push(l);
                if (h || m) {
                  if (l.modifier === "+" || l.modifier === "*") {
                    var E = l.modifier === "*" ? "?" : "";
                    d += "(?:" + h + "((?:" + l.pattern + ")(?:" + m + h + "(?:" + l.pattern + "))*)" + m + ")" + E;
                  } else {
                    d += "(?:" + h + "(" + l.pattern + ")" + m + ")" + l.modifier;
                  }
                } else {
                  d += "(" + l.pattern + ")" + l.modifier;
                }
              } else {
                d += "(?:" + h + m + ")" + l.modifier;
              }
            }
          }
          if (u) {
            if (!i) d += s + "?";
            d += !n.endsWith ? "$" : "(?=" + c + ")";
          } else {
            var T = e2[e2.length - 1];
            var y = typeof T === "string" ? s.indexOf(T[T.length - 1]) > -1 : T === void 0;
            if (!i) {
              d += "(?:" + s + "(?=" + c + "))?";
            }
            if (!y) {
              d += "(?=" + s + "|" + c + ")";
            }
          }
          return new RegExp(d, flags(n));
        }
        r.tokensToRegexp = tokensToRegexp;
        function pathToRegexp(e2, r2, n) {
          if (e2 instanceof RegExp) return regexpToRegexp(e2, r2);
          if (Array.isArray(e2)) return arrayToRegexp(e2, r2, n);
          return stringToRegexp(e2, r2, n);
        }
        r.pathToRegexp = pathToRegexp;
      })();
      module.exports = e;
    })();
  }
});

// ../../../../node_modules/next/dist/shared/lib/router/utils/path-match.js
var require_path_match = __commonJS({
  "../../../../node_modules/next/dist/shared/lib/router/utils/path-match.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "getPathMatch", {
      enumerable: true,
      get: function() {
        return getPathMatch;
      }
    });
    var _pathtoregexp = require_path_to_regexp();
    function getPathMatch(path, options) {
      const keys = [];
      const regexp = (0, _pathtoregexp.pathToRegexp)(path, keys, {
        delimiter: "/",
        sensitive: typeof (options == null ? void 0 : options.sensitive) === "boolean" ? options.sensitive : false,
        strict: options == null ? void 0 : options.strict
      });
      const matcher = (0, _pathtoregexp.regexpToFunction)((options == null ? void 0 : options.regexModifier) ? new RegExp(options.regexModifier(regexp.source), regexp.flags) : regexp, keys);
      return (pathname, params) => {
        if (typeof pathname !== "string") return false;
        const match = matcher(pathname);
        if (!match) return false;
        if (options == null ? void 0 : options.removeUnnamedParams) {
          for (const key of keys) {
            if (typeof key.name === "number") {
              delete match.params[key.name];
            }
          }
        }
        return {
          ...params,
          ...match.params
        };
      };
    }
  }
});

// ../../../../node_modules/next/dist/shared/lib/router/utils/parse-url.js
var require_parse_url = __commonJS({
  "../../../../node_modules/next/dist/shared/lib/router/utils/parse-url.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "parseUrl", {
      enumerable: true,
      get: function() {
        return parseUrl;
      }
    });
    var _querystring = require_querystring();
    var _parserelativeurl = require_parse_relative_url();
    function parseUrl(url) {
      if (url.startsWith("/")) {
        return (0, _parserelativeurl.parseRelativeUrl)(url);
      }
      const parsedURL = new URL(url);
      return {
        hash: parsedURL.hash,
        hostname: parsedURL.hostname,
        href: parsedURL.href,
        pathname: parsedURL.pathname,
        port: parsedURL.port,
        protocol: parsedURL.protocol,
        query: (0, _querystring.searchParamsToUrlQuery)(parsedURL.searchParams),
        search: parsedURL.search
      };
    }
  }
});

// ../../../../node_modules/next/dist/client/components/app-router-headers.js
var require_app_router_headers = __commonJS({
  "../../../../node_modules/next/dist/client/components/app-router-headers.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all) Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
      });
    }
    _export(exports, {
      ACTION_HEADER: function() {
        return ACTION_HEADER;
      },
      FLIGHT_HEADERS: function() {
        return FLIGHT_HEADERS;
      },
      NEXT_DID_POSTPONE_HEADER: function() {
        return NEXT_DID_POSTPONE_HEADER;
      },
      NEXT_HMR_REFRESH_HEADER: function() {
        return NEXT_HMR_REFRESH_HEADER;
      },
      NEXT_IS_PRERENDER_HEADER: function() {
        return NEXT_IS_PRERENDER_HEADER;
      },
      NEXT_ROUTER_PREFETCH_HEADER: function() {
        return NEXT_ROUTER_PREFETCH_HEADER;
      },
      NEXT_ROUTER_SEGMENT_PREFETCH_HEADER: function() {
        return NEXT_ROUTER_SEGMENT_PREFETCH_HEADER;
      },
      NEXT_ROUTER_STALE_TIME_HEADER: function() {
        return NEXT_ROUTER_STALE_TIME_HEADER;
      },
      NEXT_ROUTER_STATE_TREE_HEADER: function() {
        return NEXT_ROUTER_STATE_TREE_HEADER;
      },
      NEXT_RSC_UNION_QUERY: function() {
        return NEXT_RSC_UNION_QUERY;
      },
      NEXT_URL: function() {
        return NEXT_URL;
      },
      RSC_CONTENT_TYPE_HEADER: function() {
        return RSC_CONTENT_TYPE_HEADER;
      },
      RSC_HEADER: function() {
        return RSC_HEADER;
      }
    });
    var RSC_HEADER = "RSC";
    var ACTION_HEADER = "Next-Action";
    var NEXT_ROUTER_STATE_TREE_HEADER = "Next-Router-State-Tree";
    var NEXT_ROUTER_PREFETCH_HEADER = "Next-Router-Prefetch";
    var NEXT_ROUTER_SEGMENT_PREFETCH_HEADER = "Next-Router-Segment-Prefetch";
    var NEXT_HMR_REFRESH_HEADER = "Next-HMR-Refresh";
    var NEXT_URL = "Next-Url";
    var RSC_CONTENT_TYPE_HEADER = "text/x-component";
    var FLIGHT_HEADERS = [
      RSC_HEADER,
      NEXT_ROUTER_STATE_TREE_HEADER,
      NEXT_ROUTER_PREFETCH_HEADER,
      NEXT_HMR_REFRESH_HEADER,
      NEXT_ROUTER_SEGMENT_PREFETCH_HEADER
    ];
    var NEXT_RSC_UNION_QUERY = "_rsc";
    var NEXT_ROUTER_STALE_TIME_HEADER = "x-nextjs-stale-time";
    var NEXT_DID_POSTPONE_HEADER = "x-nextjs-postponed";
    var NEXT_IS_PRERENDER_HEADER = "x-nextjs-prerender";
    if ((typeof exports.default === "function" || typeof exports.default === "object" && exports.default !== null) && typeof exports.default.__esModule === "undefined") {
      Object.defineProperty(exports.default, "__esModule", { value: true });
      Object.assign(exports.default, exports);
      module.exports = exports.default;
    }
  }
});

// ../../../../node_modules/next/dist/compiled/cookie/index.js
var require_cookie = __commonJS({
  "../../../../node_modules/next/dist/compiled/cookie/index.js"(exports, module) {
    (() => {
      "use strict";
      if (typeof __nccwpck_require__ !== "undefined") __nccwpck_require__.ab = __dirname + "/";
      var e = {};
      (() => {
        var r = e;
        r.parse = parse;
        r.serialize = serialize;
        var i = decodeURIComponent;
        var t = encodeURIComponent;
        var a = /; */;
        var n = /^[\u0009\u0020-\u007e\u0080-\u00ff]+$/;
        function parse(e2, r2) {
          if (typeof e2 !== "string") {
            throw new TypeError("argument str must be a string");
          }
          var t2 = {};
          var n2 = r2 || {};
          var o = e2.split(a);
          var s = n2.decode || i;
          for (var p = 0; p < o.length; p++) {
            var f = o[p];
            var u = f.indexOf("=");
            if (u < 0) {
              continue;
            }
            var v = f.substr(0, u).trim();
            var c = f.substr(++u, f.length).trim();
            if ('"' == c[0]) {
              c = c.slice(1, -1);
            }
            if (void 0 == t2[v]) {
              t2[v] = tryDecode(c, s);
            }
          }
          return t2;
        }
        function serialize(e2, r2, i2) {
          var a2 = i2 || {};
          var o = a2.encode || t;
          if (typeof o !== "function") {
            throw new TypeError("option encode is invalid");
          }
          if (!n.test(e2)) {
            throw new TypeError("argument name is invalid");
          }
          var s = o(r2);
          if (s && !n.test(s)) {
            throw new TypeError("argument val is invalid");
          }
          var p = e2 + "=" + s;
          if (null != a2.maxAge) {
            var f = a2.maxAge - 0;
            if (isNaN(f) || !isFinite(f)) {
              throw new TypeError("option maxAge is invalid");
            }
            p += "; Max-Age=" + Math.floor(f);
          }
          if (a2.domain) {
            if (!n.test(a2.domain)) {
              throw new TypeError("option domain is invalid");
            }
            p += "; Domain=" + a2.domain;
          }
          if (a2.path) {
            if (!n.test(a2.path)) {
              throw new TypeError("option path is invalid");
            }
            p += "; Path=" + a2.path;
          }
          if (a2.expires) {
            if (typeof a2.expires.toUTCString !== "function") {
              throw new TypeError("option expires is invalid");
            }
            p += "; Expires=" + a2.expires.toUTCString();
          }
          if (a2.httpOnly) {
            p += "; HttpOnly";
          }
          if (a2.secure) {
            p += "; Secure";
          }
          if (a2.sameSite) {
            var u = typeof a2.sameSite === "string" ? a2.sameSite.toLowerCase() : a2.sameSite;
            switch (u) {
              case true:
                p += "; SameSite=Strict";
                break;
              case "lax":
                p += "; SameSite=Lax";
                break;
              case "strict":
                p += "; SameSite=Strict";
                break;
              case "none":
                p += "; SameSite=None";
                break;
              default:
                throw new TypeError("option sameSite is invalid");
            }
          }
          return p;
        }
        function tryDecode(e2, r2) {
          try {
            return r2(e2);
          } catch (r3) {
            return e2;
          }
        }
      })();
      module.exports = e;
    })();
  }
});

// ../../../../node_modules/next/dist/server/api-utils/get-cookie-parser.js
var require_get_cookie_parser = __commonJS({
  "../../../../node_modules/next/dist/server/api-utils/get-cookie-parser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "getCookieParser", {
      enumerable: true,
      get: function() {
        return getCookieParser;
      }
    });
    function getCookieParser(headers) {
      return function parseCookie() {
        const { cookie } = headers;
        if (!cookie) {
          return {};
        }
        const { parse: parseCookieFn } = require_cookie();
        return parseCookieFn(Array.isArray(cookie) ? cookie.join("; ") : cookie);
      };
    }
  }
});

// ../../../../node_modules/next/dist/shared/lib/router/utils/prepare-destination.js
var require_prepare_destination = __commonJS({
  "../../../../node_modules/next/dist/shared/lib/router/utils/prepare-destination.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all) Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
      });
    }
    _export(exports, {
      compileNonPath: function() {
        return compileNonPath;
      },
      matchHas: function() {
        return matchHas;
      },
      prepareDestination: function() {
        return prepareDestination;
      }
    });
    var _pathtoregexp = require_path_to_regexp();
    var _escaperegexp = require_escape_regexp();
    var _parseurl = require_parse_url();
    var _interceptionroutes = require_interception_routes();
    var _approuterheaders = require_app_router_headers();
    var _getcookieparser = require_get_cookie_parser();
    function getSafeParamName(paramName) {
      let newParamName = "";
      for (let i = 0; i < paramName.length; i++) {
        const charCode = paramName.charCodeAt(i);
        if (charCode > 64 && charCode < 91 || // A-Z
        charCode > 96 && charCode < 123) {
          newParamName += paramName[i];
        }
      }
      return newParamName;
    }
    function escapeSegment(str, segmentName) {
      return str.replace(new RegExp(":" + (0, _escaperegexp.escapeStringRegexp)(segmentName), "g"), "__ESC_COLON_" + segmentName);
    }
    function unescapeSegments(str) {
      return str.replace(/__ESC_COLON_/gi, ":");
    }
    function matchHas(req, query, has, missing) {
      if (has === void 0) has = [];
      if (missing === void 0) missing = [];
      const params = {};
      const hasMatch = (hasItem) => {
        let value;
        let key = hasItem.key;
        switch (hasItem.type) {
          case "header": {
            key = key.toLowerCase();
            value = req.headers[key];
            break;
          }
          case "cookie": {
            if ("cookies" in req) {
              value = req.cookies[hasItem.key];
            } else {
              const cookies = (0, _getcookieparser.getCookieParser)(req.headers)();
              value = cookies[hasItem.key];
            }
            break;
          }
          case "query": {
            value = query[key];
            break;
          }
          case "host": {
            const { host } = (req == null ? void 0 : req.headers) || {};
            const hostname = host == null ? void 0 : host.split(":", 1)[0].toLowerCase();
            value = hostname;
            break;
          }
          default: {
            break;
          }
        }
        if (!hasItem.value && value) {
          params[getSafeParamName(key)] = value;
          return true;
        } else if (value) {
          const matcher = new RegExp("^" + hasItem.value + "$");
          const matches = Array.isArray(value) ? value.slice(-1)[0].match(matcher) : value.match(matcher);
          if (matches) {
            if (Array.isArray(matches)) {
              if (matches.groups) {
                Object.keys(matches.groups).forEach((groupKey) => {
                  params[groupKey] = matches.groups[groupKey];
                });
              } else if (hasItem.type === "host" && matches[0]) {
                params.host = matches[0];
              }
            }
            return true;
          }
        }
        return false;
      };
      const allMatch = has.every((item) => hasMatch(item)) && !missing.some((item) => hasMatch(item));
      if (allMatch) {
        return params;
      }
      return false;
    }
    function compileNonPath(value, params) {
      if (!value.includes(":")) {
        return value;
      }
      for (const key of Object.keys(params)) {
        if (value.includes(":" + key)) {
          value = value.replace(new RegExp(":" + key + "\\*", "g"), ":" + key + "--ESCAPED_PARAM_ASTERISKS").replace(new RegExp(":" + key + "\\?", "g"), ":" + key + "--ESCAPED_PARAM_QUESTION").replace(new RegExp(":" + key + "\\+", "g"), ":" + key + "--ESCAPED_PARAM_PLUS").replace(new RegExp(":" + key + "(?!\\w)", "g"), "--ESCAPED_PARAM_COLON" + key);
        }
      }
      value = value.replace(/(:|\*|\?|\+|\(|\)|\{|\})/g, "\\$1").replace(/--ESCAPED_PARAM_PLUS/g, "+").replace(/--ESCAPED_PARAM_COLON/g, ":").replace(/--ESCAPED_PARAM_QUESTION/g, "?").replace(/--ESCAPED_PARAM_ASTERISKS/g, "*");
      return (0, _pathtoregexp.compile)("/" + value, {
        validate: false
      })(params).slice(1);
    }
    function prepareDestination(args) {
      const query = Object.assign({}, args.query);
      delete query.__nextLocale;
      delete query.__nextDefaultLocale;
      delete query.__nextDataReq;
      delete query.__nextInferredLocaleFromDefault;
      delete query[_approuterheaders.NEXT_RSC_UNION_QUERY];
      let escapedDestination = args.destination;
      for (const param of Object.keys({
        ...args.params,
        ...query
      })) {
        escapedDestination = param ? escapeSegment(escapedDestination, param) : escapedDestination;
      }
      const parsedDestination = (0, _parseurl.parseUrl)(escapedDestination);
      const destQuery = parsedDestination.query;
      const destPath = unescapeSegments("" + parsedDestination.pathname + (parsedDestination.hash || ""));
      const destHostname = unescapeSegments(parsedDestination.hostname || "");
      const destPathParamKeys = [];
      const destHostnameParamKeys = [];
      (0, _pathtoregexp.pathToRegexp)(destPath, destPathParamKeys);
      (0, _pathtoregexp.pathToRegexp)(destHostname, destHostnameParamKeys);
      const destParams = [];
      destPathParamKeys.forEach((key) => destParams.push(key.name));
      destHostnameParamKeys.forEach((key) => destParams.push(key.name));
      const destPathCompiler = (0, _pathtoregexp.compile)(
        destPath,
        // we don't validate while compiling the destination since we should
        // have already validated before we got to this point and validating
        // breaks compiling destinations with named pattern params from the source
        // e.g. /something:hello(.*) -> /another/:hello is broken with validation
        // since compile validation is meant for reversing and not for inserting
        // params from a separate path-regex into another
        {
          validate: false
        }
      );
      const destHostnameCompiler = (0, _pathtoregexp.compile)(destHostname, {
        validate: false
      });
      for (const [key, strOrArray] of Object.entries(destQuery)) {
        if (Array.isArray(strOrArray)) {
          destQuery[key] = strOrArray.map((value) => compileNonPath(unescapeSegments(value), args.params));
        } else if (typeof strOrArray === "string") {
          destQuery[key] = compileNonPath(unescapeSegments(strOrArray), args.params);
        }
      }
      let paramKeys = Object.keys(args.params).filter((name) => name !== "nextInternalLocale");
      if (args.appendParamsToQuery && !paramKeys.some((key) => destParams.includes(key))) {
        for (const key of paramKeys) {
          if (!(key in destQuery)) {
            destQuery[key] = args.params[key];
          }
        }
      }
      let newUrl;
      if ((0, _interceptionroutes.isInterceptionRouteAppPath)(destPath)) {
        for (const segment of destPath.split("/")) {
          const marker = _interceptionroutes.INTERCEPTION_ROUTE_MARKERS.find((m) => segment.startsWith(m));
          if (marker) {
            if (marker === "(..)(..)") {
              args.params["0"] = "(..)";
              args.params["1"] = "(..)";
            } else {
              args.params["0"] = marker;
            }
            break;
          }
        }
      }
      try {
        newUrl = destPathCompiler(args.params);
        const [pathname, hash] = newUrl.split("#", 2);
        parsedDestination.hostname = destHostnameCompiler(args.params);
        parsedDestination.pathname = pathname;
        parsedDestination.hash = (hash ? "#" : "") + (hash || "");
        delete parsedDestination.search;
      } catch (err) {
        if (err.message.match(/Expected .*? to not repeat, but got an array/)) {
          throw new Error("To use a multi-match in the destination you must add `*` at the end of the param name to signify it should repeat. https://nextjs.org/docs/messages/invalid-multi-match");
        }
        throw err;
      }
      parsedDestination.query = {
        ...query,
        ...parsedDestination.query
      };
      return {
        newUrl,
        destQuery,
        parsedDestination
      };
    }
  }
});

// ../../../../node_modules/next/dist/client/remove-base-path.js
var require_remove_base_path = __commonJS({
  "../../../../node_modules/next/dist/client/remove-base-path.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "removeBasePath", {
      enumerable: true,
      get: function() {
        return removeBasePath;
      }
    });
    var _hasbasepath = require_has_base_path();
    var basePath = process.env.__NEXT_ROUTER_BASEPATH || "";
    function removeBasePath(path) {
      if (process.env.__NEXT_MANUAL_CLIENT_BASE_PATH) {
        if (!(0, _hasbasepath.hasBasePath)(path)) {
          return path;
        }
      }
      if (basePath.length === 0) return path;
      path = path.slice(basePath.length);
      if (!path.startsWith("/")) path = "/" + path;
      return path;
    }
    if ((typeof exports.default === "function" || typeof exports.default === "object" && exports.default !== null) && typeof exports.default.__esModule === "undefined") {
      Object.defineProperty(exports.default, "__esModule", { value: true });
      Object.assign(exports.default, exports);
      module.exports = exports.default;
    }
  }
});

// ../../../../node_modules/next/dist/shared/lib/router/utils/resolve-rewrites.js
var require_resolve_rewrites = __commonJS({
  "../../../../node_modules/next/dist/shared/lib/router/utils/resolve-rewrites.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return resolveRewrites;
      }
    });
    var _pathmatch = require_path_match();
    var _preparedestination = require_prepare_destination();
    var _removetrailingslash = require_remove_trailing_slash();
    var _normalizelocalepath = require_normalize_locale_path();
    var _removebasepath = require_remove_base_path();
    var _parserelativeurl = require_parse_relative_url();
    function resolveRewrites(asPath, pages, rewrites, query, resolveHref, locales) {
      let matchedPage = false;
      let externalDest = false;
      let parsedAs = (0, _parserelativeurl.parseRelativeUrl)(asPath);
      let fsPathname = (0, _removetrailingslash.removeTrailingSlash)((0, _normalizelocalepath.normalizeLocalePath)((0, _removebasepath.removeBasePath)(parsedAs.pathname), locales).pathname);
      let resolvedHref;
      const handleRewrite = (rewrite) => {
        const matcher = (0, _pathmatch.getPathMatch)(rewrite.source + (process.env.__NEXT_TRAILING_SLASH ? "(/)?" : ""), {
          removeUnnamedParams: true,
          strict: true
        });
        let params = matcher(parsedAs.pathname);
        if ((rewrite.has || rewrite.missing) && params) {
          const hasParams = (0, _preparedestination.matchHas)({
            headers: {
              host: document.location.hostname,
              "user-agent": navigator.userAgent
            },
            cookies: document.cookie.split("; ").reduce((acc, item) => {
              const [key, ...value] = item.split("=");
              acc[key] = value.join("=");
              return acc;
            }, {})
          }, parsedAs.query, rewrite.has, rewrite.missing);
          if (hasParams) {
            Object.assign(params, hasParams);
          } else {
            params = false;
          }
        }
        if (params) {
          if (!rewrite.destination) {
            externalDest = true;
            return true;
          }
          const destRes = (0, _preparedestination.prepareDestination)({
            appendParamsToQuery: true,
            destination: rewrite.destination,
            params,
            query
          });
          parsedAs = destRes.parsedDestination;
          asPath = destRes.newUrl;
          Object.assign(query, destRes.parsedDestination.query);
          fsPathname = (0, _removetrailingslash.removeTrailingSlash)((0, _normalizelocalepath.normalizeLocalePath)((0, _removebasepath.removeBasePath)(asPath), locales).pathname);
          if (pages.includes(fsPathname)) {
            matchedPage = true;
            resolvedHref = fsPathname;
            return true;
          }
          resolvedHref = resolveHref(fsPathname);
          if (resolvedHref !== asPath && pages.includes(resolvedHref)) {
            matchedPage = true;
            return true;
          }
        }
      };
      let finished = false;
      for (let i = 0; i < rewrites.beforeFiles.length; i++) {
        handleRewrite(rewrites.beforeFiles[i]);
      }
      matchedPage = pages.includes(fsPathname);
      if (!matchedPage) {
        if (!finished) {
          for (let i = 0; i < rewrites.afterFiles.length; i++) {
            if (handleRewrite(rewrites.afterFiles[i])) {
              finished = true;
              break;
            }
          }
        }
        if (!finished) {
          resolvedHref = resolveHref(fsPathname);
          matchedPage = pages.includes(resolvedHref);
          finished = matchedPage;
        }
        if (!finished) {
          for (let i = 0; i < rewrites.fallback.length; i++) {
            if (handleRewrite(rewrites.fallback[i])) {
              finished = true;
              break;
            }
          }
        }
      }
      return {
        asPath,
        parsedAs,
        matchedPage,
        resolvedHref,
        externalDest
      };
    }
  }
});

// ../../../../node_modules/next/dist/client/remove-locale.js
var require_remove_locale = __commonJS({
  "../../../../node_modules/next/dist/client/remove-locale.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "removeLocale", {
      enumerable: true,
      get: function() {
        return removeLocale;
      }
    });
    var _parsepath = require_parse_path();
    function removeLocale(path, locale) {
      if (process.env.__NEXT_I18N_SUPPORT) {
        const { pathname } = (0, _parsepath.parsePath)(path);
        const pathLower = pathname.toLowerCase();
        const localeLower = locale == null ? void 0 : locale.toLowerCase();
        return locale && (pathLower.startsWith("/" + localeLower + "/") || pathLower === "/" + localeLower) ? (pathname.length === locale.length + 1 ? "/" : "") + path.slice(locale.length + 1) : path;
      }
      return path;
    }
    if ((typeof exports.default === "function" || typeof exports.default === "object" && exports.default !== null) && typeof exports.default.__esModule === "undefined") {
      Object.defineProperty(exports.default, "__esModule", { value: true });
      Object.assign(exports.default, exports);
      module.exports = exports.default;
    }
  }
});

// ../../../../node_modules/next/dist/lib/is-api-route.js
var require_is_api_route = __commonJS({
  "../../../../node_modules/next/dist/lib/is-api-route.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "isAPIRoute", {
      enumerable: true,
      get: function() {
        return isAPIRoute;
      }
    });
    function isAPIRoute(value) {
      return value === "/api" || Boolean(value == null ? void 0 : value.startsWith("/api/"));
    }
  }
});

// ../../../../node_modules/next/dist/shared/lib/router/utils/remove-path-prefix.js
var require_remove_path_prefix = __commonJS({
  "../../../../node_modules/next/dist/shared/lib/router/utils/remove-path-prefix.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "removePathPrefix", {
      enumerable: true,
      get: function() {
        return removePathPrefix;
      }
    });
    var _pathhasprefix = require_path_has_prefix();
    function removePathPrefix(path, prefix) {
      if (!(0, _pathhasprefix.pathHasPrefix)(path, prefix)) {
        return path;
      }
      const withoutPrefix = path.slice(prefix.length);
      if (withoutPrefix.startsWith("/")) {
        return withoutPrefix;
      }
      return "/" + withoutPrefix;
    }
  }
});

// ../../../../node_modules/next/dist/shared/lib/router/utils/get-next-pathname-info.js
var require_get_next_pathname_info = __commonJS({
  "../../../../node_modules/next/dist/shared/lib/router/utils/get-next-pathname-info.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "getNextPathnameInfo", {
      enumerable: true,
      get: function() {
        return getNextPathnameInfo;
      }
    });
    var _normalizelocalepath = require_normalize_locale_path();
    var _removepathprefix = require_remove_path_prefix();
    var _pathhasprefix = require_path_has_prefix();
    function getNextPathnameInfo(pathname, options) {
      var _options_nextConfig;
      const { basePath, i18n, trailingSlash } = (_options_nextConfig = options.nextConfig) != null ? _options_nextConfig : {};
      const info = {
        pathname,
        trailingSlash: pathname !== "/" ? pathname.endsWith("/") : trailingSlash
      };
      if (basePath && (0, _pathhasprefix.pathHasPrefix)(info.pathname, basePath)) {
        info.pathname = (0, _removepathprefix.removePathPrefix)(info.pathname, basePath);
        info.basePath = basePath;
      }
      let pathnameNoDataPrefix = info.pathname;
      if (info.pathname.startsWith("/_next/data/") && info.pathname.endsWith(".json")) {
        const paths = info.pathname.replace(/^\/_next\/data\//, "").replace(/\.json$/, "").split("/");
        const buildId = paths[0];
        info.buildId = buildId;
        pathnameNoDataPrefix = paths[1] !== "index" ? "/" + paths.slice(1).join("/") : "/";
        if (options.parseData === true) {
          info.pathname = pathnameNoDataPrefix;
        }
      }
      if (i18n) {
        let result = options.i18nProvider ? options.i18nProvider.analyze(info.pathname) : (0, _normalizelocalepath.normalizeLocalePath)(info.pathname, i18n.locales);
        info.locale = result.detectedLocale;
        var _result_pathname;
        info.pathname = (_result_pathname = result.pathname) != null ? _result_pathname : info.pathname;
        if (!result.detectedLocale && info.buildId) {
          result = options.i18nProvider ? options.i18nProvider.analyze(pathnameNoDataPrefix) : (0, _normalizelocalepath.normalizeLocalePath)(pathnameNoDataPrefix, i18n.locales);
          if (result.detectedLocale) {
            info.locale = result.detectedLocale;
          }
        }
      }
      return info;
    }
  }
});

// ../../../../node_modules/next/dist/shared/lib/router/utils/add-path-suffix.js
var require_add_path_suffix = __commonJS({
  "../../../../node_modules/next/dist/shared/lib/router/utils/add-path-suffix.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "addPathSuffix", {
      enumerable: true,
      get: function() {
        return addPathSuffix;
      }
    });
    var _parsepath = require_parse_path();
    function addPathSuffix(path, suffix) {
      if (!path.startsWith("/") || !suffix) {
        return path;
      }
      const { pathname, query, hash } = (0, _parsepath.parsePath)(path);
      return "" + pathname + suffix + query + hash;
    }
  }
});

// ../../../../node_modules/next/dist/shared/lib/router/utils/format-next-pathname-info.js
var require_format_next_pathname_info = __commonJS({
  "../../../../node_modules/next/dist/shared/lib/router/utils/format-next-pathname-info.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "formatNextPathnameInfo", {
      enumerable: true,
      get: function() {
        return formatNextPathnameInfo;
      }
    });
    var _removetrailingslash = require_remove_trailing_slash();
    var _addpathprefix = require_add_path_prefix();
    var _addpathsuffix = require_add_path_suffix();
    var _addlocale = require_add_locale();
    function formatNextPathnameInfo(info) {
      let pathname = (0, _addlocale.addLocale)(info.pathname, info.locale, info.buildId ? void 0 : info.defaultLocale, info.ignorePrefix);
      if (info.buildId || !info.trailingSlash) {
        pathname = (0, _removetrailingslash.removeTrailingSlash)(pathname);
      }
      if (info.buildId) {
        pathname = (0, _addpathsuffix.addPathSuffix)((0, _addpathprefix.addPathPrefix)(pathname, "/_next/data/" + info.buildId), info.pathname === "/" ? "index.json" : ".json");
      }
      pathname = (0, _addpathprefix.addPathPrefix)(pathname, info.basePath);
      return !info.buildId && info.trailingSlash ? !pathname.endsWith("/") ? (0, _addpathsuffix.addPathSuffix)(pathname, "/") : pathname : (0, _removetrailingslash.removeTrailingSlash)(pathname);
    }
  }
});

// ../../../../node_modules/next/dist/shared/lib/router/utils/compare-states.js
var require_compare_states = __commonJS({
  "../../../../node_modules/next/dist/shared/lib/router/utils/compare-states.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "compareRouterStates", {
      enumerable: true,
      get: function() {
        return compareRouterStates;
      }
    });
    function compareRouterStates(a, b) {
      const stateKeys = Object.keys(a);
      if (stateKeys.length !== Object.keys(b).length) return false;
      for (let i = stateKeys.length; i--; ) {
        const key = stateKeys[i];
        if (key === "query") {
          const queryKeys = Object.keys(a.query);
          if (queryKeys.length !== Object.keys(b.query).length) {
            return false;
          }
          for (let j = queryKeys.length; j--; ) {
            const queryKey = queryKeys[j];
            if (!b.query.hasOwnProperty(queryKey) || a.query[queryKey] !== b.query[queryKey]) {
              return false;
            }
          }
        } else if (!b.hasOwnProperty(key) || a[key] !== b[key]) {
          return false;
        }
      }
      return true;
    }
  }
});

// ../../../../node_modules/next/dist/shared/lib/router/utils/is-bot.js
var require_is_bot = __commonJS({
  "../../../../node_modules/next/dist/shared/lib/router/utils/is-bot.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "isBot", {
      enumerable: true,
      get: function() {
        return isBot;
      }
    });
    var BOT_UA_RE = /Googlebot|Mediapartners-Google|AdsBot-Google|googleweblight|Storebot-Google|Google-PageRenderer|Bingbot|BingPreview|Slurp|DuckDuckBot|baiduspider|yandex|sogou|LinkedInBot|bitlybot|tumblr|vkShare|quora link preview|facebookexternalhit|facebookcatalog|Twitterbot|applebot|redditbot|Slackbot|Discordbot|WhatsApp|SkypeUriPreview|ia_archiver/i;
    function isBot(userAgent) {
      return BOT_UA_RE.test(userAgent);
    }
  }
});

// ../../../../node_modules/next/dist/shared/lib/router/utils/handle-smooth-scroll.js
var require_handle_smooth_scroll = __commonJS({
  "../../../../node_modules/next/dist/shared/lib/router/utils/handle-smooth-scroll.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "handleSmoothScroll", {
      enumerable: true,
      get: function() {
        return handleSmoothScroll;
      }
    });
    function handleSmoothScroll(fn, options) {
      if (options === void 0) options = {};
      if (options.onlyHashChange) {
        fn();
        return;
      }
      const htmlElement = document.documentElement;
      const existing = htmlElement.style.scrollBehavior;
      htmlElement.style.scrollBehavior = "auto";
      if (!options.dontForceLayout) {
        htmlElement.getClientRects();
      }
      fn();
      htmlElement.style.scrollBehavior = existing;
    }
  }
});

// browser-external:fs
var require_fs = __commonJS({
  "browser-external:fs"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "fs" has been externalized for browser compatibility. Cannot access "fs.${key}" in client code. See https://vite.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// browser-external:stream
var require_stream = __commonJS({
  "browser-external:stream"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "stream" has been externalized for browser compatibility. Cannot access "stream.${key}" in client code. See https://vite.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// browser-external:zlib
var require_zlib = __commonJS({
  "browser-external:zlib"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "zlib" has been externalized for browser compatibility. Cannot access "zlib.${key}" in client code. See https://vite.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// ../../../../node_modules/next/dist/compiled/gzip-size/index.js
var require_gzip_size = __commonJS({
  "../../../../node_modules/next/dist/compiled/gzip-size/index.js"(exports, module) {
    (() => {
      var e = { 154: (e2, r2, t2) => {
        var n = t2(781);
        var o = ["write", "end", "destroy"];
        var i = ["resume", "pause"];
        var s = ["data", "close"];
        var c = Array.prototype.slice;
        e2.exports = duplex;
        function forEach(e3, r3) {
          if (e3.forEach) {
            return e3.forEach(r3);
          }
          for (var t3 = 0; t3 < e3.length; t3++) {
            r3(e3[t3], t3);
          }
        }
        function duplex(e3, r3) {
          var t3 = new n();
          var a = false;
          forEach(o, proxyWriter);
          forEach(i, proxyReader);
          forEach(s, proxyStream);
          r3.on("end", handleEnd);
          e3.on("drain", function() {
            t3.emit("drain");
          });
          e3.on("error", reemit);
          r3.on("error", reemit);
          t3.writable = e3.writable;
          t3.readable = r3.readable;
          return t3;
          function proxyWriter(r4) {
            t3[r4] = method;
            function method() {
              return e3[r4].apply(e3, arguments);
            }
          }
          function proxyReader(e4) {
            t3[e4] = method;
            function method() {
              t3.emit(e4);
              var n2 = r3[e4];
              if (n2) {
                return n2.apply(r3, arguments);
              }
              r3.emit(e4);
            }
          }
          function proxyStream(e4) {
            r3.on(e4, reemit2);
            function reemit2() {
              var r4 = c.call(arguments);
              r4.unshift(e4);
              t3.emit.apply(t3, r4);
            }
          }
          function handleEnd() {
            if (a) {
              return;
            }
            a = true;
            var e4 = c.call(arguments);
            e4.unshift("end");
            t3.emit.apply(t3, e4);
          }
          function reemit(e4) {
            t3.emit("error", e4);
          }
        }
      }, 349: (e2, r2, t2) => {
        "use strict";
        const n = t2(147);
        const o = t2(781);
        const i = t2(796);
        const s = t2(154);
        const c = t2(530);
        const getOptions = (e3) => Object.assign({ level: 9 }, e3);
        e2.exports = (e3, r3) => {
          if (!e3) {
            return Promise.resolve(0);
          }
          return c(i.gzip)(e3, getOptions(r3)).then((e4) => e4.length).catch((e4) => 0);
        };
        e2.exports.sync = (e3, r3) => i.gzipSync(e3, getOptions(r3)).length;
        e2.exports.stream = (e3) => {
          const r3 = new o.PassThrough();
          const t3 = new o.PassThrough();
          const n2 = s(r3, t3);
          let c2 = 0;
          const a = i.createGzip(getOptions(e3)).on("data", (e4) => {
            c2 += e4.length;
          }).on("error", () => {
            n2.gzipSize = 0;
          }).on("end", () => {
            n2.gzipSize = c2;
            n2.emit("gzip-size", c2);
            t3.end();
          });
          r3.pipe(a);
          r3.pipe(t3, { end: false });
          return n2;
        };
        e2.exports.file = (r3, t3) => new Promise((o2, i2) => {
          const s2 = n.createReadStream(r3);
          s2.on("error", i2);
          const c2 = s2.pipe(e2.exports.stream(t3));
          c2.on("error", i2);
          c2.on("gzip-size", o2);
        });
        e2.exports.fileSync = (r3, t3) => e2.exports.sync(n.readFileSync(r3), t3);
      }, 530: (e2) => {
        "use strict";
        const processFn = (e3, r2) => function(...t2) {
          const n = r2.promiseModule;
          return new n((n2, o) => {
            if (r2.multiArgs) {
              t2.push((...e4) => {
                if (r2.errorFirst) {
                  if (e4[0]) {
                    o(e4);
                  } else {
                    e4.shift();
                    n2(e4);
                  }
                } else {
                  n2(e4);
                }
              });
            } else if (r2.errorFirst) {
              t2.push((e4, r3) => {
                if (e4) {
                  o(e4);
                } else {
                  n2(r3);
                }
              });
            } else {
              t2.push(n2);
            }
            e3.apply(this, t2);
          });
        };
        e2.exports = (e3, r2) => {
          r2 = Object.assign({ exclude: [/.+(Sync|Stream)$/], errorFirst: true, promiseModule: Promise }, r2);
          const t2 = typeof e3;
          if (!(e3 !== null && (t2 === "object" || t2 === "function"))) {
            throw new TypeError(`Expected \`input\` to be a \`Function\` or \`Object\`, got \`${e3 === null ? "null" : t2}\``);
          }
          const filter = (e4) => {
            const match = (r3) => typeof r3 === "string" ? e4 === r3 : r3.test(e4);
            return r2.include ? r2.include.some(match) : !r2.exclude.some(match);
          };
          let n;
          if (t2 === "function") {
            n = function(...t3) {
              return r2.excludeMain ? e3(...t3) : processFn(e3, r2).apply(this, t3);
            };
          } else {
            n = Object.create(Object.getPrototypeOf(e3));
          }
          for (const t3 in e3) {
            const o = e3[t3];
            n[t3] = typeof o === "function" && filter(t3) ? processFn(o, r2) : o;
          }
          return n;
        };
      }, 147: (e2) => {
        "use strict";
        e2.exports = require_fs();
      }, 781: (e2) => {
        "use strict";
        e2.exports = require_stream();
      }, 796: (e2) => {
        "use strict";
        e2.exports = require_zlib();
      } };
      var r = {};
      function __nccwpck_require__2(t2) {
        var n = r[t2];
        if (n !== void 0) {
          return n.exports;
        }
        var o = r[t2] = { exports: {} };
        var i = true;
        try {
          e[t2](o, o.exports, __nccwpck_require__2);
          i = false;
        } finally {
          if (i) delete r[t2];
        }
        return o.exports;
      }
      if (typeof __nccwpck_require__2 !== "undefined") __nccwpck_require__2.ab = __dirname + "/";
      var t = __nccwpck_require__2(349);
      module.exports = t;
    })();
  }
});

// ../../../../node_modules/next/dist/shared/lib/bloom-filter.js
var require_bloom_filter = __commonJS({
  "../../../../node_modules/next/dist/shared/lib/bloom-filter.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "BloomFilter", {
      enumerable: true,
      get: function() {
        return BloomFilter;
      }
    });
    function murmurhash2(str) {
      let h = 0;
      for (let i = 0; i < str.length; i++) {
        const c = str.charCodeAt(i);
        h = Math.imul(h ^ c, 1540483477);
        h ^= h >>> 13;
        h = Math.imul(h, 1540483477);
      }
      return h >>> 0;
    }
    var DEFAULT_ERROR_RATE = 1e-4;
    var BloomFilter = class _BloomFilter {
      static from(items, errorRate) {
        if (errorRate === void 0) errorRate = DEFAULT_ERROR_RATE;
        const filter = new _BloomFilter(items.length, errorRate);
        for (const item of items) {
          filter.add(item);
        }
        return filter;
      }
      export() {
        const data = {
          numItems: this.numItems,
          errorRate: this.errorRate,
          numBits: this.numBits,
          numHashes: this.numHashes,
          bitArray: this.bitArray
        };
        if (process.env.NEXT_RUNTIME === "nodejs") {
          if (this.errorRate < DEFAULT_ERROR_RATE) {
            const filterData = JSON.stringify(data);
            const gzipSize = require_gzip_size().sync(filterData);
            if (gzipSize > 1024) {
              console.warn("Creating filter with error rate less than 0.1% (0.001) can increase the size dramatically proceed with caution. Received error rate " + this.errorRate + " resulted in size " + filterData.length + " bytes, " + gzipSize + " bytes (gzip)");
            }
          }
        }
        return data;
      }
      import(data) {
        this.numItems = data.numItems;
        this.errorRate = data.errorRate;
        this.numBits = data.numBits;
        this.numHashes = data.numHashes;
        this.bitArray = data.bitArray;
      }
      add(item) {
        const hashValues = this.getHashValues(item);
        hashValues.forEach((hash) => {
          this.bitArray[hash] = 1;
        });
      }
      contains(item) {
        const hashValues = this.getHashValues(item);
        return hashValues.every((hash) => this.bitArray[hash]);
      }
      getHashValues(item) {
        const hashValues = [];
        for (let i = 1; i <= this.numHashes; i++) {
          const hash = murmurhash2("" + item + i) % this.numBits;
          hashValues.push(hash);
        }
        return hashValues;
      }
      constructor(numItems, errorRate = DEFAULT_ERROR_RATE) {
        this.numItems = numItems;
        this.errorRate = errorRate;
        this.numBits = Math.ceil(-(numItems * Math.log(errorRate)) / (Math.log(2) * Math.log(2)));
        this.numHashes = Math.ceil(this.numBits / numItems * Math.log(2));
        this.bitArray = new Array(this.numBits).fill(0);
      }
    };
  }
});

// ../../../../node_modules/next/dist/compiled/react-is/cjs/react-is.development.js
var require_react_is_development = __commonJS({
  "../../../../node_modules/next/dist/compiled/react-is/cjs/react-is.development.js"(exports) {
    "use strict";
    (function() {
      function typeOf(object) {
        if ("object" === typeof object && null !== object) {
          var $$typeof = object.$$typeof;
          switch ($$typeof) {
            case REACT_ELEMENT_TYPE:
              switch (object = object.type, object) {
                case REACT_FRAGMENT_TYPE:
                case REACT_PROFILER_TYPE:
                case REACT_STRICT_MODE_TYPE:
                case REACT_SUSPENSE_TYPE:
                case REACT_SUSPENSE_LIST_TYPE:
                  return object;
                default:
                  switch (object = object && object.$$typeof, object) {
                    case REACT_CONTEXT_TYPE:
                    case REACT_FORWARD_REF_TYPE:
                    case REACT_LAZY_TYPE:
                    case REACT_MEMO_TYPE:
                      return object;
                    case REACT_CONSUMER_TYPE:
                      return object;
                    default:
                      return $$typeof;
                  }
              }
            case REACT_PORTAL_TYPE:
              return $$typeof;
          }
        }
      }
      var REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"), REACT_PORTAL_TYPE = Symbol.for("react.portal"), REACT_FRAGMENT_TYPE = Symbol.for("react.fragment"), REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode"), REACT_PROFILER_TYPE = Symbol.for("react.profiler");
      Symbol.for("react.provider");
      var REACT_CONSUMER_TYPE = Symbol.for("react.consumer"), REACT_CONTEXT_TYPE = Symbol.for("react.context"), REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref"), REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"), REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list"), REACT_MEMO_TYPE = Symbol.for("react.memo"), REACT_LAZY_TYPE = Symbol.for("react.lazy"), REACT_OFFSCREEN_TYPE = Symbol.for("react.offscreen"), REACT_CLIENT_REFERENCE = Symbol.for("react.client.reference");
      exports.ContextConsumer = REACT_CONSUMER_TYPE;
      exports.ContextProvider = REACT_CONTEXT_TYPE;
      exports.Element = REACT_ELEMENT_TYPE;
      exports.ForwardRef = REACT_FORWARD_REF_TYPE;
      exports.Fragment = REACT_FRAGMENT_TYPE;
      exports.Lazy = REACT_LAZY_TYPE;
      exports.Memo = REACT_MEMO_TYPE;
      exports.Portal = REACT_PORTAL_TYPE;
      exports.Profiler = REACT_PROFILER_TYPE;
      exports.StrictMode = REACT_STRICT_MODE_TYPE;
      exports.Suspense = REACT_SUSPENSE_TYPE;
      exports.SuspenseList = REACT_SUSPENSE_LIST_TYPE;
      exports.isContextConsumer = function(object) {
        return typeOf(object) === REACT_CONSUMER_TYPE;
      };
      exports.isContextProvider = function(object) {
        return typeOf(object) === REACT_CONTEXT_TYPE;
      };
      exports.isElement = function(object) {
        return "object" === typeof object && null !== object && object.$$typeof === REACT_ELEMENT_TYPE;
      };
      exports.isForwardRef = function(object) {
        return typeOf(object) === REACT_FORWARD_REF_TYPE;
      };
      exports.isFragment = function(object) {
        return typeOf(object) === REACT_FRAGMENT_TYPE;
      };
      exports.isLazy = function(object) {
        return typeOf(object) === REACT_LAZY_TYPE;
      };
      exports.isMemo = function(object) {
        return typeOf(object) === REACT_MEMO_TYPE;
      };
      exports.isPortal = function(object) {
        return typeOf(object) === REACT_PORTAL_TYPE;
      };
      exports.isProfiler = function(object) {
        return typeOf(object) === REACT_PROFILER_TYPE;
      };
      exports.isStrictMode = function(object) {
        return typeOf(object) === REACT_STRICT_MODE_TYPE;
      };
      exports.isSuspense = function(object) {
        return typeOf(object) === REACT_SUSPENSE_TYPE;
      };
      exports.isSuspenseList = function(object) {
        return typeOf(object) === REACT_SUSPENSE_LIST_TYPE;
      };
      exports.isValidElementType = function(type) {
        return "string" === typeof type || "function" === typeof type || type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || type === REACT_OFFSCREEN_TYPE || "object" === typeof type && null !== type && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_CONSUMER_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_CLIENT_REFERENCE || void 0 !== type.getModuleId) ? true : false;
      };
      exports.typeOf = typeOf;
    })();
  }
});

// ../../../../node_modules/next/dist/compiled/react-is/index.js
var require_react_is = __commonJS({
  "../../../../node_modules/next/dist/compiled/react-is/index.js"(exports, module) {
    "use strict";
    if (false) {
      module.exports = null;
    } else {
      module.exports = require_react_is_development();
    }
  }
});

// ../../../../node_modules/next/dist/shared/lib/router/router.js
var require_router = __commonJS({
  "../../../../node_modules/next/dist/shared/lib/router/router.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all) Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
      });
    }
    _export(exports, {
      createKey: function() {
        return createKey;
      },
      default: function() {
        return Router;
      },
      matchesMiddleware: function() {
        return matchesMiddleware;
      }
    });
    var _interop_require_default = require_interop_require_default();
    var _interop_require_wildcard = require_interop_require_wildcard();
    var _removetrailingslash = require_remove_trailing_slash();
    var _routeloader = require_route_loader();
    var _script = require_script();
    var _iserror = _interop_require_wildcard._(require_is_error());
    var _denormalizepagepath = require_denormalize_page_path();
    var _normalizelocalepath = require_normalize_locale_path();
    var _mitt = _interop_require_default._(require_mitt());
    var _utils = require_utils();
    var _isdynamic = require_is_dynamic();
    var _parserelativeurl = require_parse_relative_url();
    var _resolverewrites = _interop_require_default._(require_resolve_rewrites());
    var _routematcher = require_route_matcher();
    var _routeregex = require_route_regex();
    var _formaturl = require_format_url();
    var _detectdomainlocale = require_detect_domain_locale();
    var _parsepath = require_parse_path();
    var _addlocale = require_add_locale2();
    var _removelocale = require_remove_locale();
    var _removebasepath = require_remove_base_path();
    var _addbasepath = require_add_base_path();
    var _hasbasepath = require_has_base_path();
    var _resolvehref = require_resolve_href();
    var _isapiroute = require_is_api_route();
    var _getnextpathnameinfo = require_get_next_pathname_info();
    var _formatnextpathnameinfo = require_format_next_pathname_info();
    var _comparestates = require_compare_states();
    var _islocalurl = require_is_local_url();
    var _isbot = require_is_bot();
    var _omit = require_omit();
    var _interpolateas = require_interpolate_as();
    var _handlesmoothscroll = require_handle_smooth_scroll();
    var _constants = require_constants();
    function buildCancellationError() {
      return Object.assign(new Error("Route Cancelled"), {
        cancelled: true
      });
    }
    async function matchesMiddleware(options) {
      const matchers = await Promise.resolve(options.router.pageLoader.getMiddleware());
      if (!matchers) return false;
      const { pathname: asPathname } = (0, _parsepath.parsePath)(options.asPath);
      const cleanedAs = (0, _hasbasepath.hasBasePath)(asPathname) ? (0, _removebasepath.removeBasePath)(asPathname) : asPathname;
      const asWithBasePathAndLocale = (0, _addbasepath.addBasePath)((0, _addlocale.addLocale)(cleanedAs, options.locale));
      return matchers.some((m) => new RegExp(m.regexp).test(asWithBasePathAndLocale));
    }
    function stripOrigin(url) {
      const origin = (0, _utils.getLocationOrigin)();
      return url.startsWith(origin) ? url.substring(origin.length) : url;
    }
    function prepareUrlAs(router, url, as) {
      let [resolvedHref, resolvedAs] = (0, _resolvehref.resolveHref)(router, url, true);
      const origin = (0, _utils.getLocationOrigin)();
      const hrefWasAbsolute = resolvedHref.startsWith(origin);
      const asWasAbsolute = resolvedAs && resolvedAs.startsWith(origin);
      resolvedHref = stripOrigin(resolvedHref);
      resolvedAs = resolvedAs ? stripOrigin(resolvedAs) : resolvedAs;
      const preparedUrl = hrefWasAbsolute ? resolvedHref : (0, _addbasepath.addBasePath)(resolvedHref);
      const preparedAs = as ? stripOrigin((0, _resolvehref.resolveHref)(router, as)) : resolvedAs || resolvedHref;
      return {
        url: preparedUrl,
        as: asWasAbsolute ? preparedAs : (0, _addbasepath.addBasePath)(preparedAs)
      };
    }
    function resolveDynamicRoute(pathname, pages) {
      const cleanPathname = (0, _removetrailingslash.removeTrailingSlash)((0, _denormalizepagepath.denormalizePagePath)(pathname));
      if (cleanPathname === "/404" || cleanPathname === "/_error") {
        return pathname;
      }
      if (!pages.includes(cleanPathname)) {
        pages.some((page) => {
          if ((0, _isdynamic.isDynamicRoute)(page) && (0, _routeregex.getRouteRegex)(page).re.test(cleanPathname)) {
            pathname = page;
            return true;
          }
        });
      }
      return (0, _removetrailingslash.removeTrailingSlash)(pathname);
    }
    function getMiddlewareData(source, response, options) {
      const nextConfig = {
        basePath: options.router.basePath,
        i18n: {
          locales: options.router.locales
        },
        trailingSlash: Boolean(process.env.__NEXT_TRAILING_SLASH)
      };
      const rewriteHeader = response.headers.get("x-nextjs-rewrite");
      let rewriteTarget = rewriteHeader || response.headers.get("x-nextjs-matched-path");
      const matchedPath = response.headers.get(_constants.MATCHED_PATH_HEADER);
      if (matchedPath && !rewriteTarget && !matchedPath.includes("__next_data_catchall") && !matchedPath.includes("/_error") && !matchedPath.includes("/404")) {
        rewriteTarget = matchedPath;
      }
      if (rewriteTarget) {
        if (rewriteTarget.startsWith("/") || process.env.__NEXT_EXTERNAL_MIDDLEWARE_REWRITE_RESOLVE) {
          const parsedRewriteTarget = (0, _parserelativeurl.parseRelativeUrl)(rewriteTarget);
          const pathnameInfo = (0, _getnextpathnameinfo.getNextPathnameInfo)(parsedRewriteTarget.pathname, {
            nextConfig,
            parseData: true
          });
          let fsPathname = (0, _removetrailingslash.removeTrailingSlash)(pathnameInfo.pathname);
          return Promise.all([
            options.router.pageLoader.getPageList(),
            (0, _routeloader.getClientBuildManifest)()
          ]).then((param) => {
            let [pages, { __rewrites: rewrites }] = param;
            let as = (0, _addlocale.addLocale)(pathnameInfo.pathname, pathnameInfo.locale);
            if ((0, _isdynamic.isDynamicRoute)(as) || !rewriteHeader && pages.includes((0, _normalizelocalepath.normalizeLocalePath)((0, _removebasepath.removeBasePath)(as), options.router.locales).pathname)) {
              const parsedSource = (0, _getnextpathnameinfo.getNextPathnameInfo)((0, _parserelativeurl.parseRelativeUrl)(source).pathname, {
                nextConfig: process.env.__NEXT_HAS_REWRITES ? void 0 : nextConfig,
                parseData: true
              });
              as = (0, _addbasepath.addBasePath)(parsedSource.pathname);
              parsedRewriteTarget.pathname = as;
            }
            if (process.env.__NEXT_HAS_REWRITES) {
              const result = (0, _resolverewrites.default)(as, pages, rewrites, parsedRewriteTarget.query, (path) => resolveDynamicRoute(path, pages), options.router.locales);
              if (result.matchedPage) {
                parsedRewriteTarget.pathname = result.parsedAs.pathname;
                as = parsedRewriteTarget.pathname;
                Object.assign(parsedRewriteTarget.query, result.parsedAs.query);
              }
            } else if (!pages.includes(fsPathname)) {
              const resolvedPathname = resolveDynamicRoute(fsPathname, pages);
              if (resolvedPathname !== fsPathname) {
                fsPathname = resolvedPathname;
              }
            }
            const resolvedHref = !pages.includes(fsPathname) ? resolveDynamicRoute((0, _normalizelocalepath.normalizeLocalePath)((0, _removebasepath.removeBasePath)(parsedRewriteTarget.pathname), options.router.locales).pathname, pages) : fsPathname;
            if ((0, _isdynamic.isDynamicRoute)(resolvedHref)) {
              const matches = (0, _routematcher.getRouteMatcher)((0, _routeregex.getRouteRegex)(resolvedHref))(as);
              Object.assign(parsedRewriteTarget.query, matches || {});
            }
            return {
              type: "rewrite",
              parsedAs: parsedRewriteTarget,
              resolvedHref
            };
          });
        }
        const src = (0, _parsepath.parsePath)(source);
        const pathname = (0, _formatnextpathnameinfo.formatNextPathnameInfo)({
          ...(0, _getnextpathnameinfo.getNextPathnameInfo)(src.pathname, {
            nextConfig,
            parseData: true
          }),
          defaultLocale: options.router.defaultLocale,
          buildId: ""
        });
        return Promise.resolve({
          type: "redirect-external",
          destination: "" + pathname + src.query + src.hash
        });
      }
      const redirectTarget = response.headers.get("x-nextjs-redirect");
      if (redirectTarget) {
        if (redirectTarget.startsWith("/")) {
          const src = (0, _parsepath.parsePath)(redirectTarget);
          const pathname = (0, _formatnextpathnameinfo.formatNextPathnameInfo)({
            ...(0, _getnextpathnameinfo.getNextPathnameInfo)(src.pathname, {
              nextConfig,
              parseData: true
            }),
            defaultLocale: options.router.defaultLocale,
            buildId: ""
          });
          return Promise.resolve({
            type: "redirect-internal",
            newAs: "" + pathname + src.query + src.hash,
            newUrl: "" + pathname + src.query + src.hash
          });
        }
        return Promise.resolve({
          type: "redirect-external",
          destination: redirectTarget
        });
      }
      return Promise.resolve({
        type: "next"
      });
    }
    async function withMiddlewareEffects(options) {
      const matches = await matchesMiddleware(options);
      if (!matches || !options.fetchData) {
        return null;
      }
      const data = await options.fetchData();
      const effect = await getMiddlewareData(data.dataHref, data.response, options);
      return {
        dataHref: data.dataHref,
        json: data.json,
        response: data.response,
        text: data.text,
        cacheKey: data.cacheKey,
        effect
      };
    }
    var manualScrollRestoration = process.env.__NEXT_SCROLL_RESTORATION && typeof window !== "undefined" && "scrollRestoration" in window.history && !!function() {
      try {
        let v = "__next";
        return sessionStorage.setItem(v, v), sessionStorage.removeItem(v), true;
      } catch (n) {
      }
    }();
    var SSG_DATA_NOT_FOUND = Symbol("SSG_DATA_NOT_FOUND");
    function fetchRetry(url, attempts, options) {
      return fetch(url, {
        // Cookies are required to be present for Next.js' SSG "Preview Mode".
        // Cookies may also be required for `getServerSideProps`.
        //
        // > `fetch` won’t send cookies, unless you set the credentials init
        // > option.
        // https://developer.mozilla.org/docs/Web/API/Fetch_API/Using_Fetch
        //
        // > For maximum browser compatibility when it comes to sending &
        // > receiving cookies, always supply the `credentials: 'same-origin'`
        // > option instead of relying on the default.
        // https://github.com/github/fetch#caveats
        credentials: "same-origin",
        method: options.method || "GET",
        headers: Object.assign({}, options.headers, {
          "x-nextjs-data": "1"
        })
      }).then((response) => {
        return !response.ok && attempts > 1 && response.status >= 500 ? fetchRetry(url, attempts - 1, options) : response;
      });
    }
    function tryToParseAsJSON(text) {
      try {
        return JSON.parse(text);
      } catch (error) {
        return null;
      }
    }
    function fetchNextData(param) {
      let { dataHref, inflightCache, isPrefetch, hasMiddleware, isServerRender, parseJSON, persistCache, isBackground, unstable_skipClientCache } = param;
      const { href: cacheKey } = new URL(dataHref, window.location.href);
      const getData = (params) => {
        var _params_method;
        return fetchRetry(dataHref, isServerRender ? 3 : 1, {
          headers: Object.assign({}, isPrefetch ? {
            purpose: "prefetch"
          } : {}, isPrefetch && hasMiddleware ? {
            "x-middleware-prefetch": "1"
          } : {}),
          method: (_params_method = params == null ? void 0 : params.method) != null ? _params_method : "GET"
        }).then((response) => {
          if (response.ok && (params == null ? void 0 : params.method) === "HEAD") {
            return {
              dataHref,
              response,
              text: "",
              json: {},
              cacheKey
            };
          }
          return response.text().then((text) => {
            if (!response.ok) {
              if (hasMiddleware && [
                301,
                302,
                307,
                308
              ].includes(response.status)) {
                return {
                  dataHref,
                  response,
                  text,
                  json: {},
                  cacheKey
                };
              }
              if (response.status === 404) {
                var _tryToParseAsJSON;
                if ((_tryToParseAsJSON = tryToParseAsJSON(text)) == null ? void 0 : _tryToParseAsJSON.notFound) {
                  return {
                    dataHref,
                    json: {
                      notFound: SSG_DATA_NOT_FOUND
                    },
                    response,
                    text,
                    cacheKey
                  };
                }
              }
              const error = new Error("Failed to load static props");
              if (!isServerRender) {
                (0, _routeloader.markAssetError)(error);
              }
              throw error;
            }
            return {
              dataHref,
              json: parseJSON ? tryToParseAsJSON(text) : null,
              response,
              text,
              cacheKey
            };
          });
        }).then((data) => {
          if (!persistCache || true) {
            delete inflightCache[cacheKey];
          }
          return data;
        }).catch((err) => {
          if (!unstable_skipClientCache) {
            delete inflightCache[cacheKey];
          }
          if (
            // chrome
            err.message === "Failed to fetch" || // firefox
            err.message === "NetworkError when attempting to fetch resource." || // safari
            err.message === "Load failed"
          ) {
            (0, _routeloader.markAssetError)(err);
          }
          throw err;
        });
      };
      if (unstable_skipClientCache && persistCache) {
        return getData({}).then((data) => {
          if (data.response.headers.get("x-middleware-cache") !== "no-cache") {
            inflightCache[cacheKey] = Promise.resolve(data);
          }
          return data;
        });
      }
      if (inflightCache[cacheKey] !== void 0) {
        return inflightCache[cacheKey];
      }
      return inflightCache[cacheKey] = getData(isBackground ? {
        method: "HEAD"
      } : {});
    }
    function createKey() {
      return Math.random().toString(36).slice(2, 10);
    }
    function handleHardNavigation(param) {
      let { url, router } = param;
      if (url === (0, _addbasepath.addBasePath)((0, _addlocale.addLocale)(router.asPath, router.locale))) {
        throw new Error("Invariant: attempted to hard navigate to the same URL " + url + " " + location.href);
      }
      window.location.href = url;
    }
    var getCancelledHandler = (param) => {
      let { route, router } = param;
      let cancelled = false;
      const cancel = router.clc = () => {
        cancelled = true;
      };
      const handleCancelled = () => {
        if (cancelled) {
          const error = new Error('Abort fetching component for route: "' + route + '"');
          error.cancelled = true;
          throw error;
        }
        if (cancel === router.clc) {
          router.clc = null;
        }
      };
      return handleCancelled;
    };
    var Router = class _Router {
      reload() {
        window.location.reload();
      }
      /**
      * Go back in history
      */
      back() {
        window.history.back();
      }
      /**
      * Go forward in history
      */
      forward() {
        window.history.forward();
      }
      /**
      * Performs a `pushState` with arguments
      * @param url of the route
      * @param as masks `url` for the browser
      * @param options object you can define `shallow` and other options
      */
      push(url, as, options) {
        if (options === void 0) options = {};
        if (process.env.__NEXT_SCROLL_RESTORATION) {
          if (manualScrollRestoration) {
            try {
              sessionStorage.setItem("__next_scroll_" + this._key, JSON.stringify({
                x: self.pageXOffset,
                y: self.pageYOffset
              }));
            } catch (e) {
            }
          }
        }
        ;
        ({ url, as } = prepareUrlAs(this, url, as));
        return this.change("pushState", url, as, options);
      }
      /**
      * Performs a `replaceState` with arguments
      * @param url of the route
      * @param as masks `url` for the browser
      * @param options object you can define `shallow` and other options
      */
      replace(url, as, options) {
        if (options === void 0) options = {};
        ;
        ({ url, as } = prepareUrlAs(this, url, as));
        return this.change("replaceState", url, as, options);
      }
      async _bfl(as, resolvedAs, locale, skipNavigate) {
        if (process.env.__NEXT_CLIENT_ROUTER_FILTER_ENABLED) {
          if (!this._bfl_s && !this._bfl_d) {
            const { BloomFilter } = require_bloom_filter();
            let staticFilterData;
            let dynamicFilterData;
            try {
              ;
              ({ __routerFilterStatic: staticFilterData, __routerFilterDynamic: dynamicFilterData } = await (0, _routeloader.getClientBuildManifest)());
            } catch (err) {
              console.error(err);
              if (skipNavigate) {
                return true;
              }
              handleHardNavigation({
                url: (0, _addbasepath.addBasePath)((0, _addlocale.addLocale)(as, locale || this.locale, this.defaultLocale)),
                router: this
              });
              return new Promise(() => {
              });
            }
            const routerFilterSValue = process.env.__NEXT_CLIENT_ROUTER_S_FILTER;
            if (!staticFilterData && routerFilterSValue) {
              staticFilterData = routerFilterSValue ? routerFilterSValue : void 0;
            }
            const routerFilterDValue = process.env.__NEXT_CLIENT_ROUTER_D_FILTER;
            if (!dynamicFilterData && routerFilterDValue) {
              dynamicFilterData = routerFilterDValue ? routerFilterDValue : void 0;
            }
            if (staticFilterData == null ? void 0 : staticFilterData.numHashes) {
              this._bfl_s = new BloomFilter(staticFilterData.numItems, staticFilterData.errorRate);
              this._bfl_s.import(staticFilterData);
            }
            if (dynamicFilterData == null ? void 0 : dynamicFilterData.numHashes) {
              this._bfl_d = new BloomFilter(dynamicFilterData.numItems, dynamicFilterData.errorRate);
              this._bfl_d.import(dynamicFilterData);
            }
          }
          let matchesBflStatic = false;
          let matchesBflDynamic = false;
          const pathsToCheck = [
            {
              as
            },
            {
              as: resolvedAs
            }
          ];
          for (const { as: curAs, allowMatchCurrent } of pathsToCheck) {
            if (curAs) {
              const asNoSlash = (0, _removetrailingslash.removeTrailingSlash)(new URL(curAs, "http://n").pathname);
              const asNoSlashLocale = (0, _addbasepath.addBasePath)((0, _addlocale.addLocale)(asNoSlash, locale || this.locale));
              if (allowMatchCurrent || asNoSlash !== (0, _removetrailingslash.removeTrailingSlash)(new URL(this.asPath, "http://n").pathname)) {
                var _this__bfl_s, _this__bfl_s1;
                matchesBflStatic = matchesBflStatic || !!((_this__bfl_s = this._bfl_s) == null ? void 0 : _this__bfl_s.contains(asNoSlash)) || !!((_this__bfl_s1 = this._bfl_s) == null ? void 0 : _this__bfl_s1.contains(asNoSlashLocale));
                for (const normalizedAS of [
                  asNoSlash,
                  asNoSlashLocale
                ]) {
                  const curAsParts = normalizedAS.split("/");
                  for (let i = 0; !matchesBflDynamic && i < curAsParts.length + 1; i++) {
                    var _this__bfl_d;
                    const currentPart = curAsParts.slice(0, i).join("/");
                    if (currentPart && ((_this__bfl_d = this._bfl_d) == null ? void 0 : _this__bfl_d.contains(currentPart))) {
                      matchesBflDynamic = true;
                      break;
                    }
                  }
                }
                if (matchesBflStatic || matchesBflDynamic) {
                  if (skipNavigate) {
                    return true;
                  }
                  handleHardNavigation({
                    url: (0, _addbasepath.addBasePath)((0, _addlocale.addLocale)(as, locale || this.locale, this.defaultLocale)),
                    router: this
                  });
                  return new Promise(() => {
                  });
                }
              }
            }
          }
        }
        return false;
      }
      async change(method, url, as, options, forcedScroll) {
        var _this_components_pathname;
        if (!(0, _islocalurl.isLocalURL)(url)) {
          handleHardNavigation({
            url,
            router: this
          });
          return false;
        }
        const isQueryUpdating = options._h === 1;
        if (!isQueryUpdating && !options.shallow) {
          await this._bfl(as, void 0, options.locale);
        }
        let shouldResolveHref = isQueryUpdating || options._shouldResolveHref || (0, _parsepath.parsePath)(url).pathname === (0, _parsepath.parsePath)(as).pathname;
        const nextState = {
          ...this.state
        };
        const readyStateChange = this.isReady !== true;
        this.isReady = true;
        const isSsr = this.isSsr;
        if (!isQueryUpdating) {
          this.isSsr = false;
        }
        if (isQueryUpdating && this.clc) {
          return false;
        }
        const prevLocale = nextState.locale;
        if (process.env.__NEXT_I18N_SUPPORT) {
          nextState.locale = options.locale === false ? this.defaultLocale : options.locale || nextState.locale;
          if (typeof options.locale === "undefined") {
            options.locale = nextState.locale;
          }
          const parsedAs = (0, _parserelativeurl.parseRelativeUrl)((0, _hasbasepath.hasBasePath)(as) ? (0, _removebasepath.removeBasePath)(as) : as);
          const localePathResult = (0, _normalizelocalepath.normalizeLocalePath)(parsedAs.pathname, this.locales);
          if (localePathResult.detectedLocale) {
            nextState.locale = localePathResult.detectedLocale;
            parsedAs.pathname = (0, _addbasepath.addBasePath)(parsedAs.pathname);
            as = (0, _formaturl.formatWithValidation)(parsedAs);
            url = (0, _addbasepath.addBasePath)((0, _normalizelocalepath.normalizeLocalePath)((0, _hasbasepath.hasBasePath)(url) ? (0, _removebasepath.removeBasePath)(url) : url, this.locales).pathname);
          }
          let didNavigate = false;
          if (process.env.__NEXT_I18N_SUPPORT) {
            var _this_locales;
            if (!((_this_locales = this.locales) == null ? void 0 : _this_locales.includes(nextState.locale))) {
              parsedAs.pathname = (0, _addlocale.addLocale)(parsedAs.pathname, nextState.locale);
              handleHardNavigation({
                url: (0, _formaturl.formatWithValidation)(parsedAs),
                router: this
              });
              didNavigate = true;
            }
          }
          const detectedDomain = (0, _detectdomainlocale.detectDomainLocale)(this.domainLocales, void 0, nextState.locale);
          if (process.env.__NEXT_I18N_SUPPORT) {
            if (!didNavigate && detectedDomain && this.isLocaleDomain && self.location.hostname !== detectedDomain.domain) {
              const asNoBasePath = (0, _removebasepath.removeBasePath)(as);
              handleHardNavigation({
                url: "http" + (detectedDomain.http ? "" : "s") + "://" + detectedDomain.domain + (0, _addbasepath.addBasePath)((nextState.locale === detectedDomain.defaultLocale ? "" : "/" + nextState.locale) + (asNoBasePath === "/" ? "" : asNoBasePath) || "/"),
                router: this
              });
              didNavigate = true;
            }
          }
          if (didNavigate) {
            return new Promise(() => {
            });
          }
        }
        if (_utils.ST) {
          performance.mark("routeChange");
        }
        const { shallow = false, scroll = true } = options;
        const routeProps = {
          shallow
        };
        if (this._inFlightRoute && this.clc) {
          if (!isSsr) {
            _Router.events.emit("routeChangeError", buildCancellationError(), this._inFlightRoute, routeProps);
          }
          this.clc();
          this.clc = null;
        }
        as = (0, _addbasepath.addBasePath)((0, _addlocale.addLocale)((0, _hasbasepath.hasBasePath)(as) ? (0, _removebasepath.removeBasePath)(as) : as, options.locale, this.defaultLocale));
        const cleanedAs = (0, _removelocale.removeLocale)((0, _hasbasepath.hasBasePath)(as) ? (0, _removebasepath.removeBasePath)(as) : as, nextState.locale);
        this._inFlightRoute = as;
        const localeChange = prevLocale !== nextState.locale;
        if (!isQueryUpdating && this.onlyAHashChange(cleanedAs) && !localeChange) {
          nextState.asPath = cleanedAs;
          _Router.events.emit("hashChangeStart", as, routeProps);
          this.changeState(method, url, as, {
            ...options,
            scroll: false
          });
          if (scroll) {
            this.scrollToHash(cleanedAs);
          }
          try {
            await this.set(nextState, this.components[nextState.route], null);
          } catch (err) {
            if ((0, _iserror.default)(err) && err.cancelled) {
              _Router.events.emit("routeChangeError", err, cleanedAs, routeProps);
            }
            throw err;
          }
          _Router.events.emit("hashChangeComplete", as, routeProps);
          return true;
        }
        let parsed = (0, _parserelativeurl.parseRelativeUrl)(url);
        let { pathname, query } = parsed;
        let pages, rewrites;
        try {
          ;
          [pages, { __rewrites: rewrites }] = await Promise.all([
            this.pageLoader.getPageList(),
            (0, _routeloader.getClientBuildManifest)(),
            this.pageLoader.getMiddleware()
          ]);
        } catch (err) {
          handleHardNavigation({
            url: as,
            router: this
          });
          return false;
        }
        if (!this.urlIsNew(cleanedAs) && !localeChange) {
          method = "replaceState";
        }
        let resolvedAs = as;
        pathname = pathname ? (0, _removetrailingslash.removeTrailingSlash)((0, _removebasepath.removeBasePath)(pathname)) : pathname;
        let route = (0, _removetrailingslash.removeTrailingSlash)(pathname);
        const parsedAsPathname = as.startsWith("/") && (0, _parserelativeurl.parseRelativeUrl)(as).pathname;
        if ((_this_components_pathname = this.components[pathname]) == null ? void 0 : _this_components_pathname.__appRouter) {
          handleHardNavigation({
            url: as,
            router: this
          });
          return new Promise(() => {
          });
        }
        const isMiddlewareRewrite = !!(parsedAsPathname && route !== parsedAsPathname && (!(0, _isdynamic.isDynamicRoute)(route) || !(0, _routematcher.getRouteMatcher)((0, _routeregex.getRouteRegex)(route))(parsedAsPathname)));
        const isMiddlewareMatch = !options.shallow && await matchesMiddleware({
          asPath: as,
          locale: nextState.locale,
          router: this
        });
        if (isQueryUpdating && isMiddlewareMatch) {
          shouldResolveHref = false;
        }
        if (shouldResolveHref && pathname !== "/_error") {
          ;
          options._shouldResolveHref = true;
          if (process.env.__NEXT_HAS_REWRITES && as.startsWith("/")) {
            const rewritesResult = (0, _resolverewrites.default)((0, _addbasepath.addBasePath)((0, _addlocale.addLocale)(cleanedAs, nextState.locale), true), pages, rewrites, query, (p) => resolveDynamicRoute(p, pages), this.locales);
            if (rewritesResult.externalDest) {
              handleHardNavigation({
                url: as,
                router: this
              });
              return true;
            }
            if (!isMiddlewareMatch) {
              resolvedAs = rewritesResult.asPath;
            }
            if (rewritesResult.matchedPage && rewritesResult.resolvedHref) {
              pathname = rewritesResult.resolvedHref;
              parsed.pathname = (0, _addbasepath.addBasePath)(pathname);
              if (!isMiddlewareMatch) {
                url = (0, _formaturl.formatWithValidation)(parsed);
              }
            }
          } else {
            parsed.pathname = resolveDynamicRoute(pathname, pages);
            if (parsed.pathname !== pathname) {
              pathname = parsed.pathname;
              parsed.pathname = (0, _addbasepath.addBasePath)(pathname);
              if (!isMiddlewareMatch) {
                url = (0, _formaturl.formatWithValidation)(parsed);
              }
            }
          }
        }
        if (!(0, _islocalurl.isLocalURL)(as)) {
          if (true) {
            throw new Error('Invalid href: "' + url + '" and as: "' + as + '", received relative href and external as\nSee more info: https://nextjs.org/docs/messages/invalid-relative-url-external-as');
          }
          handleHardNavigation({
            url: as,
            router: this
          });
          return false;
        }
        resolvedAs = (0, _removelocale.removeLocale)((0, _removebasepath.removeBasePath)(resolvedAs), nextState.locale);
        route = (0, _removetrailingslash.removeTrailingSlash)(pathname);
        let routeMatch = false;
        if ((0, _isdynamic.isDynamicRoute)(route)) {
          const parsedAs = (0, _parserelativeurl.parseRelativeUrl)(resolvedAs);
          const asPathname = parsedAs.pathname;
          const routeRegex = (0, _routeregex.getRouteRegex)(route);
          routeMatch = (0, _routematcher.getRouteMatcher)(routeRegex)(asPathname);
          const shouldInterpolate = route === asPathname;
          const interpolatedAs = shouldInterpolate ? (0, _interpolateas.interpolateAs)(route, asPathname, query) : {};
          if (!routeMatch || shouldInterpolate && !interpolatedAs.result) {
            const missingParams = Object.keys(routeRegex.groups).filter((param) => !query[param] && !routeRegex.groups[param].optional);
            if (missingParams.length > 0 && !isMiddlewareMatch) {
              if (true) {
                console.warn((shouldInterpolate ? "Interpolating href" : "Mismatching `as` and `href`") + " failed to manually provide " + ("the params: " + missingParams.join(", ") + " in the `href`'s `query`"));
              }
              throw new Error((shouldInterpolate ? "The provided `href` (" + url + ") value is missing query values (" + missingParams.join(", ") + ") to be interpolated properly. " : "The provided `as` value (" + asPathname + ") is incompatible with the `href` value (" + route + "). ") + ("Read more: https://nextjs.org/docs/messages/" + (shouldInterpolate ? "href-interpolation-failed" : "incompatible-href-as")));
            }
          } else if (shouldInterpolate) {
            as = (0, _formaturl.formatWithValidation)(Object.assign({}, parsedAs, {
              pathname: interpolatedAs.result,
              query: (0, _omit.omit)(query, interpolatedAs.params)
            }));
          } else {
            Object.assign(query, routeMatch);
          }
        }
        if (!isQueryUpdating) {
          _Router.events.emit("routeChangeStart", as, routeProps);
        }
        const isErrorRoute = this.pathname === "/404" || this.pathname === "/_error";
        try {
          var _self___NEXT_DATA___props_pageProps, _self___NEXT_DATA___props, _routeInfo_props;
          let routeInfo = await this.getRouteInfo({
            route,
            pathname,
            query,
            as,
            resolvedAs,
            routeProps,
            locale: nextState.locale,
            isPreview: nextState.isPreview,
            hasMiddleware: isMiddlewareMatch,
            unstable_skipClientCache: options.unstable_skipClientCache,
            isQueryUpdating: isQueryUpdating && !this.isFallback,
            isMiddlewareRewrite
          });
          if (!isQueryUpdating && !options.shallow) {
            await this._bfl(as, "resolvedAs" in routeInfo ? routeInfo.resolvedAs : void 0, nextState.locale);
          }
          if ("route" in routeInfo && isMiddlewareMatch) {
            pathname = routeInfo.route || route;
            route = pathname;
            if (!routeProps.shallow) {
              query = Object.assign({}, routeInfo.query || {}, query);
            }
            const cleanedParsedPathname = (0, _hasbasepath.hasBasePath)(parsed.pathname) ? (0, _removebasepath.removeBasePath)(parsed.pathname) : parsed.pathname;
            if (routeMatch && pathname !== cleanedParsedPathname) {
              Object.keys(routeMatch).forEach((key) => {
                if (routeMatch && query[key] === routeMatch[key]) {
                  delete query[key];
                }
              });
            }
            if ((0, _isdynamic.isDynamicRoute)(pathname)) {
              const prefixedAs = !routeProps.shallow && routeInfo.resolvedAs ? routeInfo.resolvedAs : (0, _addbasepath.addBasePath)((0, _addlocale.addLocale)(new URL(as, location.href).pathname, nextState.locale), true);
              let rewriteAs = prefixedAs;
              if ((0, _hasbasepath.hasBasePath)(rewriteAs)) {
                rewriteAs = (0, _removebasepath.removeBasePath)(rewriteAs);
              }
              if (process.env.__NEXT_I18N_SUPPORT) {
                const localeResult = (0, _normalizelocalepath.normalizeLocalePath)(rewriteAs, this.locales);
                nextState.locale = localeResult.detectedLocale || nextState.locale;
                rewriteAs = localeResult.pathname;
              }
              const routeRegex = (0, _routeregex.getRouteRegex)(pathname);
              const curRouteMatch = (0, _routematcher.getRouteMatcher)(routeRegex)(new URL(rewriteAs, location.href).pathname);
              if (curRouteMatch) {
                Object.assign(query, curRouteMatch);
              }
            }
          }
          if ("type" in routeInfo) {
            if (routeInfo.type === "redirect-internal") {
              return this.change(method, routeInfo.newUrl, routeInfo.newAs, options);
            } else {
              handleHardNavigation({
                url: routeInfo.destination,
                router: this
              });
              return new Promise(() => {
              });
            }
          }
          const component = routeInfo.Component;
          if (component && component.unstable_scriptLoader) {
            const scripts = [].concat(component.unstable_scriptLoader());
            scripts.forEach((script) => {
              (0, _script.handleClientScriptLoad)(script.props);
            });
          }
          if ((routeInfo.__N_SSG || routeInfo.__N_SSP) && routeInfo.props) {
            if (routeInfo.props.pageProps && routeInfo.props.pageProps.__N_REDIRECT) {
              options.locale = false;
              const destination = routeInfo.props.pageProps.__N_REDIRECT;
              if (destination.startsWith("/") && routeInfo.props.pageProps.__N_REDIRECT_BASE_PATH !== false) {
                const parsedHref = (0, _parserelativeurl.parseRelativeUrl)(destination);
                parsedHref.pathname = resolveDynamicRoute(parsedHref.pathname, pages);
                const { url: newUrl, as: newAs } = prepareUrlAs(this, destination, destination);
                return this.change(method, newUrl, newAs, options);
              }
              handleHardNavigation({
                url: destination,
                router: this
              });
              return new Promise(() => {
              });
            }
            nextState.isPreview = !!routeInfo.props.__N_PREVIEW;
            if (routeInfo.props.notFound === SSG_DATA_NOT_FOUND) {
              let notFoundRoute;
              try {
                await this.fetchComponent("/404");
                notFoundRoute = "/404";
              } catch (_) {
                notFoundRoute = "/_error";
              }
              routeInfo = await this.getRouteInfo({
                route: notFoundRoute,
                pathname: notFoundRoute,
                query,
                as,
                resolvedAs,
                routeProps: {
                  shallow: false
                },
                locale: nextState.locale,
                isPreview: nextState.isPreview,
                isNotFound: true
              });
              if ("type" in routeInfo) {
                throw new Error("Unexpected middleware effect on /404");
              }
            }
          }
          if (isQueryUpdating && this.pathname === "/_error" && ((_self___NEXT_DATA___props = self.__NEXT_DATA__.props) == null ? void 0 : (_self___NEXT_DATA___props_pageProps = _self___NEXT_DATA___props.pageProps) == null ? void 0 : _self___NEXT_DATA___props_pageProps.statusCode) === 500 && ((_routeInfo_props = routeInfo.props) == null ? void 0 : _routeInfo_props.pageProps)) {
            routeInfo.props.pageProps.statusCode = 500;
          }
          var _routeInfo_route;
          const isValidShallowRoute = options.shallow && nextState.route === ((_routeInfo_route = routeInfo.route) != null ? _routeInfo_route : route);
          var _options_scroll;
          const shouldScroll = (_options_scroll = options.scroll) != null ? _options_scroll : !isQueryUpdating && !isValidShallowRoute;
          const resetScroll = shouldScroll ? {
            x: 0,
            y: 0
          } : null;
          const upcomingScrollState = forcedScroll != null ? forcedScroll : resetScroll;
          const upcomingRouterState = {
            ...nextState,
            route,
            pathname,
            query,
            asPath: cleanedAs,
            isFallback: false
          };
          if (isQueryUpdating && isErrorRoute) {
            var _self___NEXT_DATA___props_pageProps1, _self___NEXT_DATA___props1, _routeInfo_props1;
            routeInfo = await this.getRouteInfo({
              route: this.pathname,
              pathname: this.pathname,
              query,
              as,
              resolvedAs,
              routeProps: {
                shallow: false
              },
              locale: nextState.locale,
              isPreview: nextState.isPreview,
              isQueryUpdating: isQueryUpdating && !this.isFallback
            });
            if ("type" in routeInfo) {
              throw new Error("Unexpected middleware effect on " + this.pathname);
            }
            if (this.pathname === "/_error" && ((_self___NEXT_DATA___props1 = self.__NEXT_DATA__.props) == null ? void 0 : (_self___NEXT_DATA___props_pageProps1 = _self___NEXT_DATA___props1.pageProps) == null ? void 0 : _self___NEXT_DATA___props_pageProps1.statusCode) === 500 && ((_routeInfo_props1 = routeInfo.props) == null ? void 0 : _routeInfo_props1.pageProps)) {
              routeInfo.props.pageProps.statusCode = 500;
            }
            try {
              await this.set(upcomingRouterState, routeInfo, upcomingScrollState);
            } catch (err) {
              if ((0, _iserror.default)(err) && err.cancelled) {
                _Router.events.emit("routeChangeError", err, cleanedAs, routeProps);
              }
              throw err;
            }
            return true;
          }
          _Router.events.emit("beforeHistoryChange", as, routeProps);
          this.changeState(method, url, as, options);
          const canSkipUpdating = isQueryUpdating && !upcomingScrollState && !readyStateChange && !localeChange && (0, _comparestates.compareRouterStates)(upcomingRouterState, this.state);
          if (!canSkipUpdating) {
            try {
              await this.set(upcomingRouterState, routeInfo, upcomingScrollState);
            } catch (e) {
              if (e.cancelled) routeInfo.error = routeInfo.error || e;
              else throw e;
            }
            if (routeInfo.error) {
              if (!isQueryUpdating) {
                _Router.events.emit("routeChangeError", routeInfo.error, cleanedAs, routeProps);
              }
              throw routeInfo.error;
            }
            if (process.env.__NEXT_I18N_SUPPORT) {
              if (nextState.locale) {
                document.documentElement.lang = nextState.locale;
              }
            }
            if (!isQueryUpdating) {
              _Router.events.emit("routeChangeComplete", as, routeProps);
            }
            const hashRegex = /#.+$/;
            if (shouldScroll && hashRegex.test(as)) {
              this.scrollToHash(as);
            }
          }
          return true;
        } catch (err) {
          if ((0, _iserror.default)(err) && err.cancelled) {
            return false;
          }
          throw err;
        }
      }
      changeState(method, url, as, options) {
        if (options === void 0) options = {};
        if (true) {
          if (typeof window.history === "undefined") {
            console.error("Warning: window.history is not available.");
            return;
          }
          if (typeof window.history[method] === "undefined") {
            console.error("Warning: window.history." + method + " is not available");
            return;
          }
        }
        if (method !== "pushState" || (0, _utils.getURL)() !== as) {
          this._shallow = options.shallow;
          window.history[method](
            {
              url,
              as,
              options,
              __N: true,
              key: this._key = method !== "pushState" ? this._key : createKey()
            },
            // Most browsers currently ignores this parameter, although they may use it in the future.
            // Passing the empty string here should be safe against future changes to the method.
            // https://developer.mozilla.org/docs/Web/API/History/replaceState
            "",
            as
          );
        }
      }
      async handleRouteInfoError(err, pathname, query, as, routeProps, loadErrorFail) {
        if (err.cancelled) {
          throw err;
        }
        if ((0, _routeloader.isAssetError)(err) || loadErrorFail) {
          _Router.events.emit("routeChangeError", err, as, routeProps);
          handleHardNavigation({
            url: as,
            router: this
          });
          throw buildCancellationError();
        }
        console.error(err);
        try {
          let props;
          const { page: Component, styleSheets } = await this.fetchComponent("/_error");
          const routeInfo = {
            props,
            Component,
            styleSheets,
            err,
            error: err
          };
          if (!routeInfo.props) {
            try {
              routeInfo.props = await this.getInitialProps(Component, {
                err,
                pathname,
                query
              });
            } catch (gipErr) {
              console.error("Error in error page `getInitialProps`: ", gipErr);
              routeInfo.props = {};
            }
          }
          return routeInfo;
        } catch (routeInfoErr) {
          return this.handleRouteInfoError((0, _iserror.default)(routeInfoErr) ? routeInfoErr : new Error(routeInfoErr + ""), pathname, query, as, routeProps, true);
        }
      }
      async getRouteInfo(param) {
        let { route: requestedRoute, pathname, query, as, resolvedAs, routeProps, locale, hasMiddleware, isPreview, unstable_skipClientCache, isQueryUpdating, isMiddlewareRewrite, isNotFound } = param;
        let route = requestedRoute;
        try {
          var _data_effect, _data_effect1, _data_effect2, _data_response;
          let existingInfo = this.components[route];
          if (routeProps.shallow && existingInfo && this.route === route) {
            return existingInfo;
          }
          const handleCancelled = getCancelledHandler({
            route,
            router: this
          });
          if (hasMiddleware) {
            existingInfo = void 0;
          }
          let cachedRouteInfo = existingInfo && !("initial" in existingInfo) && false ? existingInfo : void 0;
          const isBackground = isQueryUpdating;
          const fetchNextDataParams = {
            dataHref: this.pageLoader.getDataHref({
              href: (0, _formaturl.formatWithValidation)({
                pathname,
                query
              }),
              skipInterpolation: true,
              asPath: isNotFound ? "/404" : resolvedAs,
              locale
            }),
            hasMiddleware: true,
            isServerRender: this.isSsr,
            parseJSON: true,
            inflightCache: isBackground ? this.sbc : this.sdc,
            persistCache: !isPreview,
            isPrefetch: false,
            unstable_skipClientCache,
            isBackground
          };
          let data = isQueryUpdating && !isMiddlewareRewrite ? null : await withMiddlewareEffects({
            fetchData: () => fetchNextData(fetchNextDataParams),
            asPath: isNotFound ? "/404" : resolvedAs,
            locale,
            router: this
          }).catch((err) => {
            if (isQueryUpdating) {
              return null;
            }
            throw err;
          });
          if (data && (pathname === "/_error" || pathname === "/404")) {
            data.effect = void 0;
          }
          if (isQueryUpdating) {
            if (!data) {
              data = {
                json: self.__NEXT_DATA__.props
              };
            } else {
              data.json = self.__NEXT_DATA__.props;
            }
          }
          handleCancelled();
          if ((data == null ? void 0 : (_data_effect = data.effect) == null ? void 0 : _data_effect.type) === "redirect-internal" || (data == null ? void 0 : (_data_effect1 = data.effect) == null ? void 0 : _data_effect1.type) === "redirect-external") {
            return data.effect;
          }
          if ((data == null ? void 0 : (_data_effect2 = data.effect) == null ? void 0 : _data_effect2.type) === "rewrite") {
            const resolvedRoute = (0, _removetrailingslash.removeTrailingSlash)(data.effect.resolvedHref);
            const pages = await this.pageLoader.getPageList();
            if (!isQueryUpdating || pages.includes(resolvedRoute)) {
              route = resolvedRoute;
              pathname = data.effect.resolvedHref;
              query = {
                ...query,
                ...data.effect.parsedAs.query
              };
              resolvedAs = (0, _removebasepath.removeBasePath)((0, _normalizelocalepath.normalizeLocalePath)(data.effect.parsedAs.pathname, this.locales).pathname);
              existingInfo = this.components[route];
              if (routeProps.shallow && existingInfo && this.route === route && !hasMiddleware) {
                return {
                  ...existingInfo,
                  route
                };
              }
            }
          }
          if ((0, _isapiroute.isAPIRoute)(route)) {
            handleHardNavigation({
              url: as,
              router: this
            });
            return new Promise(() => {
            });
          }
          const routeInfo = cachedRouteInfo || await this.fetchComponent(route).then((res) => ({
            Component: res.page,
            styleSheets: res.styleSheets,
            __N_SSG: res.mod.__N_SSG,
            __N_SSP: res.mod.__N_SSP
          }));
          if (true) {
            const { isValidElementType } = require_react_is();
            if (!isValidElementType(routeInfo.Component)) {
              throw new Error('The default export is not a React Component in page: "' + pathname + '"');
            }
          }
          const wasBailedPrefetch = data == null ? void 0 : (_data_response = data.response) == null ? void 0 : _data_response.headers.get("x-middleware-skip");
          const shouldFetchData = routeInfo.__N_SSG || routeInfo.__N_SSP;
          if (wasBailedPrefetch && (data == null ? void 0 : data.dataHref)) {
            delete this.sdc[data.dataHref];
          }
          const { props, cacheKey } = await this._getData(async () => {
            if (shouldFetchData) {
              if ((data == null ? void 0 : data.json) && !wasBailedPrefetch) {
                return {
                  cacheKey: data.cacheKey,
                  props: data.json
                };
              }
              const dataHref = (data == null ? void 0 : data.dataHref) ? data.dataHref : this.pageLoader.getDataHref({
                href: (0, _formaturl.formatWithValidation)({
                  pathname,
                  query
                }),
                asPath: resolvedAs,
                locale
              });
              const fetched = await fetchNextData({
                dataHref,
                isServerRender: this.isSsr,
                parseJSON: true,
                inflightCache: wasBailedPrefetch ? {} : this.sdc,
                persistCache: !isPreview,
                isPrefetch: false,
                unstable_skipClientCache
              });
              return {
                cacheKey: fetched.cacheKey,
                props: fetched.json || {}
              };
            }
            return {
              headers: {},
              props: await this.getInitialProps(
                routeInfo.Component,
                // we provide AppTree later so this needs to be `any`
                {
                  pathname,
                  query,
                  asPath: as,
                  locale,
                  locales: this.locales,
                  defaultLocale: this.defaultLocale
                }
              )
            };
          });
          if (routeInfo.__N_SSP && fetchNextDataParams.dataHref && cacheKey) {
            delete this.sdc[cacheKey];
          }
          if (!this.isPreview && routeInfo.__N_SSG && false) {
            fetchNextData(Object.assign({}, fetchNextDataParams, {
              isBackground: true,
              persistCache: false,
              inflightCache: this.sbc
            })).catch(() => {
            });
          }
          props.pageProps = Object.assign({}, props.pageProps);
          routeInfo.props = props;
          routeInfo.route = route;
          routeInfo.query = query;
          routeInfo.resolvedAs = resolvedAs;
          this.components[route] = routeInfo;
          return routeInfo;
        } catch (err) {
          return this.handleRouteInfoError((0, _iserror.getProperError)(err), pathname, query, as, routeProps);
        }
      }
      set(state, data, resetScroll) {
        this.state = state;
        return this.sub(data, this.components["/_app"].Component, resetScroll);
      }
      /**
      * Callback to execute before replacing router state
      * @param cb callback to be executed
      */
      beforePopState(cb) {
        this._bps = cb;
      }
      onlyAHashChange(as) {
        if (!this.asPath) return false;
        const [oldUrlNoHash, oldHash] = this.asPath.split("#", 2);
        const [newUrlNoHash, newHash] = as.split("#", 2);
        if (newHash && oldUrlNoHash === newUrlNoHash && oldHash === newHash) {
          return true;
        }
        if (oldUrlNoHash !== newUrlNoHash) {
          return false;
        }
        return oldHash !== newHash;
      }
      scrollToHash(as) {
        const [, hash = ""] = as.split("#", 2);
        (0, _handlesmoothscroll.handleSmoothScroll)(() => {
          if (hash === "" || hash === "top") {
            window.scrollTo(0, 0);
            return;
          }
          const rawHash = decodeURIComponent(hash);
          const idEl = document.getElementById(rawHash);
          if (idEl) {
            idEl.scrollIntoView();
            return;
          }
          const nameEl = document.getElementsByName(rawHash)[0];
          if (nameEl) {
            nameEl.scrollIntoView();
          }
        }, {
          onlyHashChange: this.onlyAHashChange(as)
        });
      }
      urlIsNew(asPath) {
        return this.asPath !== asPath;
      }
      /**
      * Prefetch page code, you may wait for the data during page rendering.
      * This feature only works in production!
      * @param url the href of prefetched page
      * @param asPath the as path of the prefetched page
      */
      async prefetch(url, asPath, options) {
        if (asPath === void 0) asPath = url;
        if (options === void 0) options = {};
        if (true) {
          return;
        }
        if (typeof window !== "undefined" && (0, _isbot.isBot)(window.navigator.userAgent)) {
          return;
        }
        let parsed = (0, _parserelativeurl.parseRelativeUrl)(url);
        const urlPathname = parsed.pathname;
        let { pathname, query } = parsed;
        const originalPathname = pathname;
        if (process.env.__NEXT_I18N_SUPPORT) {
          if (options.locale === false) {
            pathname = (0, _normalizelocalepath.normalizeLocalePath)(pathname, this.locales).pathname;
            parsed.pathname = pathname;
            url = (0, _formaturl.formatWithValidation)(parsed);
            let parsedAs = (0, _parserelativeurl.parseRelativeUrl)(asPath);
            const localePathResult = (0, _normalizelocalepath.normalizeLocalePath)(parsedAs.pathname, this.locales);
            parsedAs.pathname = localePathResult.pathname;
            options.locale = localePathResult.detectedLocale || this.defaultLocale;
            asPath = (0, _formaturl.formatWithValidation)(parsedAs);
          }
        }
        const pages = await this.pageLoader.getPageList();
        let resolvedAs = asPath;
        const locale = typeof options.locale !== "undefined" ? options.locale || void 0 : this.locale;
        const isMiddlewareMatch = await matchesMiddleware({
          asPath,
          locale,
          router: this
        });
        if (process.env.__NEXT_HAS_REWRITES && asPath.startsWith("/")) {
          let rewrites;
          ({ __rewrites: rewrites } = await (0, _routeloader.getClientBuildManifest)());
          const rewritesResult = (0, _resolverewrites.default)((0, _addbasepath.addBasePath)((0, _addlocale.addLocale)(asPath, this.locale), true), pages, rewrites, parsed.query, (p) => resolveDynamicRoute(p, pages), this.locales);
          if (rewritesResult.externalDest) {
            return;
          }
          if (!isMiddlewareMatch) {
            resolvedAs = (0, _removelocale.removeLocale)((0, _removebasepath.removeBasePath)(rewritesResult.asPath), this.locale);
          }
          if (rewritesResult.matchedPage && rewritesResult.resolvedHref) {
            pathname = rewritesResult.resolvedHref;
            parsed.pathname = pathname;
            if (!isMiddlewareMatch) {
              url = (0, _formaturl.formatWithValidation)(parsed);
            }
          }
        }
        parsed.pathname = resolveDynamicRoute(parsed.pathname, pages);
        if ((0, _isdynamic.isDynamicRoute)(parsed.pathname)) {
          pathname = parsed.pathname;
          parsed.pathname = pathname;
          Object.assign(query, (0, _routematcher.getRouteMatcher)((0, _routeregex.getRouteRegex)(parsed.pathname))((0, _parsepath.parsePath)(asPath).pathname) || {});
          if (!isMiddlewareMatch) {
            url = (0, _formaturl.formatWithValidation)(parsed);
          }
        }
        const data = process.env.__NEXT_MIDDLEWARE_PREFETCH === "strict" ? null : await withMiddlewareEffects({
          fetchData: () => fetchNextData({
            dataHref: this.pageLoader.getDataHref({
              href: (0, _formaturl.formatWithValidation)({
                pathname: originalPathname,
                query
              }),
              skipInterpolation: true,
              asPath: resolvedAs,
              locale
            }),
            hasMiddleware: true,
            isServerRender: false,
            parseJSON: true,
            inflightCache: this.sdc,
            persistCache: !this.isPreview,
            isPrefetch: true
          }),
          asPath,
          locale,
          router: this
        });
        if ((data == null ? void 0 : data.effect.type) === "rewrite") {
          parsed.pathname = data.effect.resolvedHref;
          pathname = data.effect.resolvedHref;
          query = {
            ...query,
            ...data.effect.parsedAs.query
          };
          resolvedAs = data.effect.parsedAs.pathname;
          url = (0, _formaturl.formatWithValidation)(parsed);
        }
        if ((data == null ? void 0 : data.effect.type) === "redirect-external") {
          return;
        }
        const route = (0, _removetrailingslash.removeTrailingSlash)(pathname);
        if (await this._bfl(asPath, resolvedAs, options.locale, true)) {
          this.components[urlPathname] = {
            __appRouter: true
          };
        }
        await Promise.all([
          this.pageLoader._isSsg(route).then((isSsg) => {
            return isSsg ? fetchNextData({
              dataHref: (data == null ? void 0 : data.json) ? data == null ? void 0 : data.dataHref : this.pageLoader.getDataHref({
                href: url,
                asPath: resolvedAs,
                locale
              }),
              isServerRender: false,
              parseJSON: true,
              inflightCache: this.sdc,
              persistCache: !this.isPreview,
              isPrefetch: true,
              unstable_skipClientCache: options.unstable_skipClientCache || options.priority && !!process.env.__NEXT_OPTIMISTIC_CLIENT_CACHE
            }).then(() => false).catch(() => false) : false;
          }),
          this.pageLoader[options.priority ? "loadPage" : "prefetch"](route)
        ]);
      }
      async fetchComponent(route) {
        const handleCancelled = getCancelledHandler({
          route,
          router: this
        });
        try {
          const componentResult = await this.pageLoader.loadPage(route);
          handleCancelled();
          return componentResult;
        } catch (err) {
          handleCancelled();
          throw err;
        }
      }
      _getData(fn) {
        let cancelled = false;
        const cancel = () => {
          cancelled = true;
        };
        this.clc = cancel;
        return fn().then((data) => {
          if (cancel === this.clc) {
            this.clc = null;
          }
          if (cancelled) {
            const err = new Error("Loading initial props cancelled");
            err.cancelled = true;
            throw err;
          }
          return data;
        });
      }
      getInitialProps(Component, ctx) {
        const { Component: App } = this.components["/_app"];
        const AppTree = this._wrapApp(App);
        ctx.AppTree = AppTree;
        return (0, _utils.loadGetInitialProps)(App, {
          AppTree,
          Component,
          router: this,
          ctx
        });
      }
      get route() {
        return this.state.route;
      }
      get pathname() {
        return this.state.pathname;
      }
      get query() {
        return this.state.query;
      }
      get asPath() {
        return this.state.asPath;
      }
      get locale() {
        return this.state.locale;
      }
      get isFallback() {
        return this.state.isFallback;
      }
      get isPreview() {
        return this.state.isPreview;
      }
      constructor(pathname, query, as, { initialProps, pageLoader, App, wrapApp, Component, err, subscription, isFallback, locale, locales, defaultLocale, domainLocales, isPreview }) {
        this.sdc = {};
        this.sbc = {};
        this.isFirstPopStateEvent = true;
        this._key = createKey();
        this.onPopState = (e) => {
          const { isFirstPopStateEvent } = this;
          this.isFirstPopStateEvent = false;
          const state = e.state;
          if (!state) {
            const { pathname: pathname3, query: query2 } = this;
            this.changeState("replaceState", (0, _formaturl.formatWithValidation)({
              pathname: (0, _addbasepath.addBasePath)(pathname3),
              query: query2
            }), (0, _utils.getURL)());
            return;
          }
          if (state.__NA) {
            window.location.reload();
            return;
          }
          if (!state.__N) {
            return;
          }
          if (isFirstPopStateEvent && this.locale === state.options.locale && state.as === this.asPath) {
            return;
          }
          let forcedScroll;
          const { url, as: as2, options, key } = state;
          if (process.env.__NEXT_SCROLL_RESTORATION) {
            if (manualScrollRestoration) {
              if (this._key !== key) {
                try {
                  sessionStorage.setItem("__next_scroll_" + this._key, JSON.stringify({
                    x: self.pageXOffset,
                    y: self.pageYOffset
                  }));
                } catch (e2) {
                }
                try {
                  const v = sessionStorage.getItem("__next_scroll_" + key);
                  forcedScroll = JSON.parse(v);
                } catch (e2) {
                  forcedScroll = {
                    x: 0,
                    y: 0
                  };
                }
              }
            }
          }
          this._key = key;
          const { pathname: pathname2 } = (0, _parserelativeurl.parseRelativeUrl)(url);
          if (this.isSsr && as2 === (0, _addbasepath.addBasePath)(this.asPath) && pathname2 === (0, _addbasepath.addBasePath)(this.pathname)) {
            return;
          }
          if (this._bps && !this._bps(state)) {
            return;
          }
          this.change("replaceState", url, as2, Object.assign({}, options, {
            shallow: options.shallow && this._shallow,
            locale: options.locale || this.defaultLocale,
            // @ts-ignore internal value not exposed on types
            _h: 0
          }), forcedScroll);
        };
        const route = (0, _removetrailingslash.removeTrailingSlash)(pathname);
        this.components = {};
        if (pathname !== "/_error") {
          this.components[route] = {
            Component,
            initial: true,
            props: initialProps,
            err,
            __N_SSG: initialProps && initialProps.__N_SSG,
            __N_SSP: initialProps && initialProps.__N_SSP
          };
        }
        this.components["/_app"] = {
          Component: App,
          styleSheets: []
        };
        this.events = _Router.events;
        this.pageLoader = pageLoader;
        const autoExportDynamic = (0, _isdynamic.isDynamicRoute)(pathname) && self.__NEXT_DATA__.autoExport;
        this.basePath = process.env.__NEXT_ROUTER_BASEPATH || "";
        this.sub = subscription;
        this.clc = null;
        this._wrapApp = wrapApp;
        this.isSsr = true;
        this.isLocaleDomain = false;
        this.isReady = !!(self.__NEXT_DATA__.gssp || self.__NEXT_DATA__.gip || self.__NEXT_DATA__.isExperimentalCompile || self.__NEXT_DATA__.appGip && !self.__NEXT_DATA__.gsp || !autoExportDynamic && !self.location.search && !process.env.__NEXT_HAS_REWRITES);
        if (process.env.__NEXT_I18N_SUPPORT) {
          this.locales = locales;
          this.defaultLocale = defaultLocale;
          this.domainLocales = domainLocales;
          this.isLocaleDomain = !!(0, _detectdomainlocale.detectDomainLocale)(domainLocales, self.location.hostname);
        }
        this.state = {
          route,
          pathname,
          query,
          asPath: autoExportDynamic ? pathname : as,
          isPreview: !!isPreview,
          locale: process.env.__NEXT_I18N_SUPPORT ? locale : void 0,
          isFallback
        };
        this._initialMatchesMiddlewarePromise = Promise.resolve(false);
        if (typeof window !== "undefined") {
          if (!as.startsWith("//")) {
            const options = {
              locale
            };
            const asPath = (0, _utils.getURL)();
            this._initialMatchesMiddlewarePromise = matchesMiddleware({
              router: this,
              locale,
              asPath
            }).then((matches) => {
              ;
              options._shouldResolveHref = as !== pathname;
              this.changeState("replaceState", matches ? asPath : (0, _formaturl.formatWithValidation)({
                pathname: (0, _addbasepath.addBasePath)(pathname),
                query
              }), asPath, options);
              return matches;
            });
          }
          window.addEventListener("popstate", this.onPopState);
          if (process.env.__NEXT_SCROLL_RESTORATION) {
            if (manualScrollRestoration) {
              window.history.scrollRestoration = "manual";
            }
          }
        }
      }
    };
    Router.events = (0, _mitt.default)();
  }
});

// ../../../../node_modules/next/dist/client/with-router.js
var require_with_router = __commonJS({
  "../../../../node_modules/next/dist/client/with-router.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return withRouter;
      }
    });
    var _interop_require_default = require_interop_require_default();
    var _jsxruntime = require_jsx_runtime();
    var _react = _interop_require_default._(require_react());
    var _router = require_router2();
    function withRouter(ComposedComponent) {
      function WithRouterWrapper(props) {
        return (0, _jsxruntime.jsx)(ComposedComponent, {
          router: (0, _router.useRouter)(),
          ...props
        });
      }
      WithRouterWrapper.getInitialProps = ComposedComponent.getInitialProps;
      WithRouterWrapper.origGetInitialProps = ComposedComponent.origGetInitialProps;
      if (true) {
        const name = ComposedComponent.displayName || ComposedComponent.name || "Unknown";
        WithRouterWrapper.displayName = "withRouter(" + name + ")";
      }
      return WithRouterWrapper;
    }
    if ((typeof exports.default === "function" || typeof exports.default === "object" && exports.default !== null) && typeof exports.default.__esModule === "undefined") {
      Object.defineProperty(exports.default, "__esModule", { value: true });
      Object.assign(exports.default, exports);
      module.exports = exports.default;
    }
  }
});

// ../../../../node_modules/next/dist/client/router.js
var require_router2 = __commonJS({
  "../../../../node_modules/next/dist/client/router.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all) Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
      });
    }
    _export(exports, {
      Router: function() {
        return _router.default;
      },
      createRouter: function() {
        return createRouter;
      },
      // Export the singletonRouter and this is the public API.
      default: function() {
        return _default;
      },
      makePublicRouterInstance: function() {
        return makePublicRouterInstance;
      },
      useRouter: function() {
        return useRouter;
      },
      withRouter: function() {
        return _withrouter.default;
      }
    });
    var _interop_require_default = require_interop_require_default();
    var _react = _interop_require_default._(require_react());
    var _router = _interop_require_default._(require_router());
    var _routercontextsharedruntime = require_router_context_shared_runtime();
    var _iserror = _interop_require_default._(require_is_error());
    var _withrouter = _interop_require_default._(require_with_router());
    var singletonRouter = {
      router: null,
      readyCallbacks: [],
      ready(callback) {
        if (this.router) return callback();
        if (typeof window !== "undefined") {
          this.readyCallbacks.push(callback);
        }
      }
    };
    var urlPropertyFields = [
      "pathname",
      "route",
      "query",
      "asPath",
      "components",
      "isFallback",
      "basePath",
      "locale",
      "locales",
      "defaultLocale",
      "isReady",
      "isPreview",
      "isLocaleDomain",
      "domainLocales"
    ];
    var routerEvents = [
      "routeChangeStart",
      "beforeHistoryChange",
      "routeChangeComplete",
      "routeChangeError",
      "hashChangeStart",
      "hashChangeComplete"
    ];
    var coreMethodFields = [
      "push",
      "replace",
      "reload",
      "back",
      "prefetch",
      "beforePopState"
    ];
    Object.defineProperty(singletonRouter, "events", {
      get() {
        return _router.default.events;
      }
    });
    function getRouter() {
      if (!singletonRouter.router) {
        const message = 'No router instance found.\nYou should only use "next/router" on the client side of your app.\n';
        throw new Error(message);
      }
      return singletonRouter.router;
    }
    urlPropertyFields.forEach((field) => {
      Object.defineProperty(singletonRouter, field, {
        get() {
          const router = getRouter();
          return router[field];
        }
      });
    });
    coreMethodFields.forEach((field) => {
      ;
      singletonRouter[field] = function() {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        const router = getRouter();
        return router[field](...args);
      };
    });
    routerEvents.forEach((event) => {
      singletonRouter.ready(() => {
        _router.default.events.on(event, function() {
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          const eventField = "on" + event.charAt(0).toUpperCase() + event.substring(1);
          const _singletonRouter = singletonRouter;
          if (_singletonRouter[eventField]) {
            try {
              _singletonRouter[eventField](...args);
            } catch (err) {
              console.error("Error when running the Router event: " + eventField);
              console.error((0, _iserror.default)(err) ? err.message + "\n" + err.stack : err + "");
            }
          }
        });
      });
    });
    var _default = singletonRouter;
    function useRouter() {
      const router = _react.default.useContext(_routercontextsharedruntime.RouterContext);
      if (!router) {
        throw new Error("NextRouter was not mounted. https://nextjs.org/docs/messages/next-router-not-mounted");
      }
      return router;
    }
    function createRouter() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      singletonRouter.router = new _router.default(...args);
      singletonRouter.readyCallbacks.forEach((cb) => cb());
      singletonRouter.readyCallbacks = [];
      return singletonRouter.router;
    }
    function makePublicRouterInstance(router) {
      const scopedRouter = router;
      const instance = {};
      for (const property of urlPropertyFields) {
        if (typeof scopedRouter[property] === "object") {
          instance[property] = Object.assign(Array.isArray(scopedRouter[property]) ? [] : {}, scopedRouter[property]);
          continue;
        }
        instance[property] = scopedRouter[property];
      }
      instance.events = _router.default.events;
      coreMethodFields.forEach((field) => {
        instance[field] = function() {
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          return scopedRouter[field](...args);
        };
      });
      return instance;
    }
    if ((typeof exports.default === "function" || typeof exports.default === "object" && exports.default !== null) && typeof exports.default.__esModule === "undefined") {
      Object.defineProperty(exports.default, "__esModule", { value: true });
      Object.assign(exports.default, exports);
      module.exports = exports.default;
    }
  }
});

// ../../../../node_modules/next/router.js
var require_router3 = __commonJS({
  "../../../../node_modules/next/router.js"(exports, module) {
    module.exports = require_router2();
  }
});
export default require_router3();
/*! Bundled license information:

next/dist/compiled/cookie/index.js:
  (*!
   * cookie
   * Copyright(c) 2012-2014 Roman Shtylman
   * Copyright(c) 2015 Douglas Christopher Wilson
   * MIT Licensed
   *)

next/dist/compiled/react-is/cjs/react-is.development.js:
  (**
   * @license React
   * react-is.development.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)
*/
//# sourceMappingURL=next_router.js.map
